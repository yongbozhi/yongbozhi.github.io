<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>java基础</title>
      <link href="/2024/03/24/java%E5%9F%BA%E7%A1%80/"/>
      <url>/2024/03/24/java%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h2 id="接口和抽象类的区别和相同点？"><a href="#接口和抽象类的区别和相同点？" class="headerlink" title="接口和抽象类的区别和相同点？"></a>接口和抽象类的区别和相同点？</h2><p>不同点：</p><p>1.类可以实现很多个接口，但是只能继承一个抽象类</p><p>2.Java接口中声明的变量默认都是final的。抽象类可以包含非final的变量。</p><p>3.接口中所有的方法隐含的都是抽象的。而抽象类则可以同时包含抽象和非抽象的方法。</p><p>4.Java接口中的成员函数默认是public的。抽象类的成员函数可以是private，protected或者是public。</p><p>两者相同点: </p><p>1.抽象类和接口都不能直接实例化，如果要实例化，抽象类变量必须指向实现所有抽象方法的子类对象，接口变量必须指向实现所有接口方法的类对象。</p><p>2.抽象类里的抽象方法必须全部被子类所实现（若不是抽象方法则不用全部实现），如果子类不能全部实现父类抽象方法，那么该子类还只能是抽象类。同样，一个类实现接口的时候，如不能全部实现接口方法，那么该类也只能为抽象类。</p><p>扩展：对于一个final变量，如果是基本数据类型的变量，则其数值一旦在初始化之后便不能更改；如果是引用类型的变量，则在对其初始化之后便不能再让其指向另一个对象。</p><p>两种的使用场景：</p><p>abstract class在Java语言中体现的是一种继承关系，父类和派生类之间必须存在“is a”关系，即父类和派生类在概念本质上应该是相同的。对于interface 来说则不然，并不要求interface的实现者和interface定义在概念本质上是一致的，仅仅是实现了interface定义的契约而已。为了使论述便于理解，下面将通过一个简单的实例进行说明。</p><p>考虑这样一个例子，假设在我们的问题领域中有一个关于Door的抽象概念，该Door具有执行两个动作open和close，此时我们可以通过abstract class或者interface来定义一个表示该抽象概念的类型，其他具体的Door类型可以extends使用abstract class方式定义的Door或者implements使用interface方式定义的Door。看起来好像使用abstract class和interface没有大的区别。</p><p>如果现在要求Door还要具有报警的功能。我们该如何设计针对该例子的类结构呢），下面将罗列出可能的解决方案，并从设计理念层面对这些不同的方案进行分析。</p><p>解决方案一：</p><p>简单的在Door的定义中增加一个alarm方法，这种方法违反了面向对象设计中的一个核心原则ISP（Interface Segregation Priciple），在Door的定义中把Door概念本身固有的行为方法和另外一个概念“报警器“的行为方法混在了一起。这样引起的一个问题是那些仅仅依赖于Door这个概念的模块会因为“报警器“这个概念的改变（比如：修改alarm方法的参数）而改变。</p><p>解决方案二：</p><p>既然open、close和alarm属于两个不同的概念，根据ISP原则应该把它们分别定义在代表这两个概念的抽象类中。定义方式有：这两个概念都使用abstract class方式定义；两个概念都使用interface方式定义；一个概念使用abstract class方式定义，另一个概念使用interface方式定义。</p><p>显然，由于Java语言不支持多重继承，所以两个概念都使用abstract class方式定义是不可行的。后面两种方式都是可行的，但是对于它们的选择却反映出对于问题领域中的概念本质的理解、对于设计意图的反映是否正确、合理。</p><p>如果两个概念都使用interface方式来定义，那么就反映出两个问题：1、我们可能没有理解清楚问题领域，AlarmDoor在概念本质上到底是Door还是报警器？2、如果我们对于问题领域的理解没有问题，比如：我们通过对于问题领域的分析发现AlarmDoor在概念本质上和Door是一致的，那么我们在实现时就没有能够正确的揭示我们的设计意图，因为在这两个概念的定义上（均使用interface方式定义）反映不出上述含义。</p><p>如果我们对于问题领域的理解是：AlarmDoor在概念本质上是Door，同时它有具有报警的功能。我们该如何来设计、实现来明确的反映出我们的意思呢？前面已经说过，abstract class在Java语言中表示一种继承关系，而继承关系在本质上是“is a”关系。所以对于Door这个概念，我们应该使用abstarct class方式来定义。另外，AlarmDoor又具有报警功能，说明它又能够完成报警概念中定义的行为，所以报警概念可以通过interface方式定义。</p><p>这种实现方式基本上能够明确的反映出我们对于问题领域的理解，正确的揭示我们的设计意图。其实abstract class表示的是“is a”关系，interface表示的是“like a”关系，大家在选择时可以作为一个依据，当然这是建立在对问题领域的理解上的，比如：如果我们认为AlarmDoor在概念本质上是报警器，同时又具有Door的功能，那么上述的定义方式就要反过来了。</p><p>具体参考： <a href="https://cloud.tencent.com/developer/article/1434229">https://cloud.tencent.com/developer/article/1434229</a></p><h2 id="经典排序算法"><a href="#经典排序算法" class="headerlink" title="经典排序算法"></a>经典排序算法</h2><img src="/2024/03/24/java%E5%9F%BA%E7%A1%80/sort.png" class="" title="sort"><img src="/2024/03/24/java%E5%9F%BA%E7%A1%80/2.png" class="" width="2"><p><a href="https://www.runoob.com/w3cnote/ten-sorting-algorithm.html">https://www.runoob.com/w3cnote/ten-sorting-algorithm.html</a></p><h2 id="HashMap-和-Hashtable-的区别"><a href="#HashMap-和-Hashtable-的区别" class="headerlink" title="HashMap 和 Hashtable 的区别"></a>HashMap 和 Hashtable 的区别</h2><p>\1. 线程是否安全： HashMap 是⾮线程安全的， HashTable 是线程安全的,因为 HashTable 内 </p><p>部的⽅法基本都经过 synchronized 修饰。（如果你要保证线程安全的话就使⽤</p><p>ConcurrentHashMap 吧！）； </p><ol start="2"><li>效率： 因为线程安全的问题， HashMap 要⽐ HashTable 效率⾼⼀点。另外， HashTable</li></ol><p>基本被淘汰，不要在代码中使⽤它；</p><p>\3. 对 <strong>Null key</strong> 和 <strong>Null value</strong> 的⽀持： HashMap 可以存储 null 的 key 和 value，但 null 作为 </p><p>键只能有⼀个，null 作为值可以有多个；HashTable 不允许有 null 键和 null 值，否则会抛出 </p><p>NullPointerException 。 </p><p>\4. 初始容量⼤⼩和每次扩充容量⼤⼩的不同 ： ① 创建时如果不指定容量初始值， Hashtable </p><p>默认的初始⼤⼩为 11，之后每次扩充，容量变为原来的 2n+1。 HashMap 默认的初始化⼤ </p><p>⼩为 16。之后每次扩充，容量变为原来的 2 倍。② 创建时如果给定了容量初始值，那么 </p><p>Hashtable 会直接使⽤你给定的⼤⼩，⽽ HashMap 会将其扩充为 2 的幂次⽅⼤⼩ </p><p>（ HashMap 中的 tableSizeFor() ⽅法保证，下⾯给出了源代码）。也就是说 HashMap 总 </p><p>是使⽤ 2 的幂作为哈希表的⼤⼩,后⾯会介绍到为什么是 2 的幂次⽅。 </p><p>\5. 底层数据结构： JDK1.8 以后的 HashMap 在解决哈希冲突时有了重⼤的变化，当链表⻓度 </p><p>⼤于阈值（默认为 8）（将链表转换成红⿊树前会判断，如果当前数组的⻓度⼩于 64，那么 </p><p>会选择先进⾏数组扩容，⽽不是转换为红⿊树）时，将链表转化为红⿊树，以减少搜索时</p><p>间。Hashtable 没有这样的机制</p><h2 id="关于JAVA中接口存在的意义"><a href="#关于JAVA中接口存在的意义" class="headerlink" title="关于JAVA中接口存在的意义"></a>关于JAVA中接口存在的意义</h2>]]></content>
      
      
      <categories>
          
          <category> java面经 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java面试 </tag>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo搭建个人博客</title>
      <link href="/2024/03/24/hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
      <url>/2024/03/24/hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<h1 id="博客搭建过程（采用hexo框架-部署到github）"><a href="#博客搭建过程（采用hexo框架-部署到github）" class="headerlink" title="博客搭建过程（采用hexo框架+部署到github）"></a><strong>博客搭建过程（采用hexo框架+部署到github）</strong></h1><h2 id="1-前期准备"><a href="#1-前期准备" class="headerlink" title="1.前期准备"></a><strong>1.前期准备</strong></h2><h3 id="1-1-注意事项"><a href="#1-1-注意事项" class="headerlink" title="1.1 注意事项"></a><strong>1.1 注意事项</strong></h3><ul><li>很多命令既可以用Windows的cmd来完成，也可以使用git bash来完成，但是部分命令会有一些问题，为避免不必要的问题，建议全部使用git bash来执行</li><li>hexo不同版本差别比较大，网上很多文章的配置信息都是基于2.x的，所以注意不要被误导</li><li>hexo有2种_config.yml文件，一个是根目录下的全局的_config.yml，一个是各个theme下的</li></ul><h3 id="1-2-下载并安装node-js"><a href="#1-2-下载并安装node-js" class="headerlink" title="1.2 下载并安装node.js"></a><strong>1.2 下载并安装node.js</strong></h3><ul><li>官网下载：<a href="https://nodejs.org/en/">https://nodejs.org/en/</a></li><li>安装与使用：见node笔记</li><li>安装后验证：<strong>node -v</strong></li></ul><h3 id="1-3-下载并安装git"><a href="#1-3-下载并安装git" class="headerlink" title="1.3 下载并安装git"></a><strong>1.3 下载并安装git</strong></h3><ul><li>官网下载:  <a href="https://git-scm.com/download/win">https://git-scm.com/download/win</a></li><li>安装与使用：见git笔记</li><li>安装后验证：<strong>git -v</strong></li></ul><h3 id="1-4-命令行安装cnpm"><a href="#1-4-命令行安装cnpm" class="headerlink" title="1.4 命令行安装cnpm"></a><strong>1.4 命令行安装cnpm</strong></h3><ul><li>命令：<strong>npm install -g cnpm –registry&#x3D;&#x3D;<a href="https://registry.npm.taobao.org/">https://registry.npm.taobao.org</a></strong></li><li>安装后验证：<strong>cnpm -v</strong></li></ul><h3 id="1-5-命令行安装hexo"><a href="#1-5-命令行安装hexo" class="headerlink" title="1.5 命令行安装hexo"></a><strong>1.5 命令行安装hexo</strong></h3><ul><li>命令：<strong>cnpm install -g hexo-cli</strong></li><li>安装后验证：<strong>hexo  -v</strong></li></ul><hr><h2 id="2-配置github"><a href="#2-配置github" class="headerlink" title="2.配置github"></a><strong>2.配置github</strong></h2><h3 id="2-1-在github上创建仓库"><a href="#2-1-在github上创建仓库" class="headerlink" title="2.1 在github上创建仓库"></a><strong>2.1 在github上创建仓库</strong></h3><p><strong>创建：</strong></p><ul><li>新建一个名为你的用户名.github.io的仓库</li><li>比如说，如果你的github用户名是test，那么你就新建test.github.io的仓库（必须是你的用户名，其它名称无效），将来你的网站访问地址就是 <a href="http://test.github.io/">http://test.github.io</a> 了，是不是很方便？由此可见，每一个github账户最多只能创建一个这样可以直接使用域名访问的仓库。</li></ul><p><strong>注意：</strong></p><ol><li>注册的邮箱一定要验证，否则不会成功；</li><li>仓库名字必须是：username.github.io，其中username是你的用户名；</li><li>仓库创建成功不会立即生效，需要过一段时间，大概10-30分钟，或者更久；</li><li>创建页面如下：</li></ol><img src="/2024/03/24/hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/1.png" class="" title="img"><p>创建成功后，默认会在你这个仓库里生成一些示例页面，以后你的网站所有代码都是放在这个仓库里啦。</p><h3 id="2-2-绑定域名（这步可省略）"><a href="#2-2-绑定域名（这步可省略）" class="headerlink" title="2.2 绑定域名（这步可省略）"></a><strong>2.2 绑定域名（这步可省略）</strong></h3><p>当然，你不绑定域名肯定也是可以的，就用默认的 xxx.github.io 来访问，如果你想更个性一点，想拥有一个属于自己的域名，那也是OK的。</p><p>首先你要注册一个域名，域名注册以前总是推荐去godaddy，现在觉得其实国内的阿里云也挺不错的，价格也不贵，毕竟是大公司，放心！</p><p>绑定域名分2种情况：带www和不带www的。</p><p>域名配置最常见有2种方式，CNAME和A记录，CNAME填写域名，A记录填写IP，由于不带www方式只能采用A记录，所以必须先ping一下你的用户名.github.io的IP，然后到你的域名DNS设置页，将A记录指向你ping出来的IP，将CNAME指向你的用户名.github.io，这样可以保证无论是否添加www都可以访问，如下：</p><img src="/2024/03/24/hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/2.png" class="" title="img"><p>然后到你的github项目根目录新建一个名为CNAME的文件（无后缀），里面填写你的域名，加不加www看你自己喜好，因为经测试：</p><ul><li>如果你填写的是没有www的，比如 mygit.me，那么无论是访问 <a href="http://www.mygit.me/">http://www.mygit.me</a> 还是 <a href="http://mygit.me/">http://mygit.me</a> ，都会自动跳转到 <a href="http://mygit.me/">http://mygit.me</a></li><li>如果你填写的是带www的，比如 <a href="http://www.mygit.me/">www.mygit.me</a> ，那么无论是访问 <a href="http://www.mygit.me/">http://www.mygit.me</a> 还是 <a href="http://mygit.me/">http://mygit.me</a> ，都会自动跳转到 <a href="http://www.mygit.me/">http://www.mygit.me</a></li><li>如果你填写的是其它子域名，比如 abc.mygit.me，那么访问 <a href="http://abc.mygit.me/">http://abc.mygit.me</a> 没问题，但是访问 <a href="http://mygit.me/">http://mygit.me</a> ，不会自动跳转到 <a href="http://abc.mygit.me/">http://abc.mygit.me</a></li></ul><p>另外说一句，在你绑定了新域名之后，原来的你的用户名.github.io并没有失效，而是会自动跳转到你的新域名。</p><hr><h2 id="3-配置SSH免密登录"><a href="#3-配置SSH免密登录" class="headerlink" title="3. 配置SSH免密登录"></a><strong>3. 配置SSH免密登录</strong></h2><p>为什么要配置这个呢？因为你提交代码肯定要拥有你的github权限才可以，但是直接使用用户名和密码太不安全了，所以我们使用ssh key来解决本地和服务器的连接问题。</p><p><strong>操作步骤：</strong></p><p><strong>第一步：</strong>首先打开电脑文件夹，找到C:\Users\你的用户名.ssh文件夹并删除</p><p><strong>第二步：</strong>在C:\Users\你的用户名 文件夹下右键打开Git Bash Here<strong>输入命令：</strong>ssh-keygen -t rsa -C github邮件地址   生成.ssh秘钥，输入后连敲三次回车，出现下图情况代表成功</p><img src="/2024/03/24/hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/3.png" class="" title="img"><p><strong>第三步：</strong>最终生成了一个新的 C:\Users\你的用户名.ssh文件夹，打开这个文件夹，找到.ssh\id_rsa.pub文件，记事本打开并复制里面的内容</p><p><strong>第四步：</strong>打开你的github主页，进入个人设置 -&gt; SSH and GPG keys -&gt; New SSH key，把复制的内容粘贴进去，title随便填，保存即可，我们的公钥就添加成功了，设置好如下图。</p><img src="/2024/03/24/hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/4.png" class="" title="img"><p><strong>第五步：检测是否设置成功：</strong></p><p>输入命令：  $ ssh -T <a href="mailto:git@github.com">git@github.com</a> # 注意邮箱地址不用改</p><p>如果提示Are you sure you want to continue connecting (yes&#x2F;no)?，输入yes，然后会看到：</p><p>Hi liuxianan! You’ve successfully authenticated, but GitHub does not provide shell access.</p><p>看到这个信息说明SSH已配置成功！</p><p><strong>第六步：此时你还需要配置：</strong></p><p>$ git config –global user.name “liuxianan”&#x2F;&#x2F; 你的github用户名，非昵称 $ git config –global user.email  “<a href="mailto:xxx@qq.com">xxx@qq.com</a>“&#x2F;&#x2F; 填写你的github注册邮箱</p><p>具体这个配置是干嘛的我没仔细深究。</p><hr><h2 id="4-使用-hexo-搭建博客"><a href="#4-使用-hexo-搭建博客" class="headerlink" title="4.使用 hexo 搭建博客"></a><strong>4.使用 hexo 搭建博客</strong></h2><h3 id="4-1-初始化"><a href="#4-1-初始化" class="headerlink" title="4.1 初始化"></a><strong>4.1 初始化</strong></h3><p><strong>第一步：</strong>在电脑的某个地方新建一个名为hexo的文件夹（名字可以随便取），比如我的是E:\xpzsData\hexocode，由于这个文件夹将来就作为你存放代码的地方，所以最好不要随便放</p><p><strong>第二步：</strong>在E:\xpzsData\hexocode文件夹下右键打开 Git Bash Here，输入hexo init 初始化</p><ul><li>hexo会自动下载一些文件到这个目录，包括node_modules，目录结构如下图：</li></ul><img src="/2024/03/24/hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/5.png" class="" title="img"><p><strong>第三步：</strong>执行以下命令之后，hexo就会在public文件夹生成相关html文件，这些文件将来都是要提交到github去的：</p><img src="/2024/03/24/hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/6.png" class="" title="img"><p><strong>第四步：</strong>hexo s 是开启本地预览服务，打开浏览器访问 <a href="http://localhost:4000/">http://localhost:4000</a> 即可看到内容，很多人会碰到浏览器一直在转圈但是就是加载不出来的问题，一般情况下是因为端口占用的缘故，因为4000这个端口太常见了，解决端口冲突问题请参考这篇文章<a href="https://www.runoob.com/w3cnote/windows-finds-port-usage.html">https://www.runoob.com/w3cnote/windows-finds-port-usage.html</a></p><ul><li>到这里初始化就完成了</li></ul><h3 id="4-2-将博客部署到-github-个人主页上"><a href="#4-2-将博客部署到-github-个人主页上" class="headerlink" title="4.2 将博客部署到 github 个人主页上"></a><strong>4.2 将博客部署到 github 个人主页上</strong></h3><p><strong>第一步：</strong>在E:\xpzsData\hexocode目录下安装 hexo-deployer-git 插件</p><ul><li><strong>安装命令：</strong> npm install hexo-deployer-git –save  </li><li>必须安装，否则执行hexo d 的话会报如下错误：</li></ul><img src="/2024/03/24/hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/7.png" class="" title="img"><p><strong>第二步：</strong>编辑E:\xpzsData\hexocode目录下的 _config.yml 文件, 在文件末尾添加如下内容：</p><img src="/2024/03/24/hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/8.png" class="" title="img"><ul><li>注意：其中 repo 中的内容即为 github 个人主页链接地址，具体看下图：</li></ul><img src="/2024/03/24/hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/9.png" class="" title="img"><p><strong>第三步：</strong>在E:\xpzsData\hexocode目录下, <strong>输入命令：hexo d</strong> 将本地 blog 推送到 github仓库, 也可能需要输入 username &amp; pwd。</p><ul><li>推送成功后, 在浏览器中输入对应域名, 即可访问 <a href="https://reclusew.github.io/">https://reclusew.github.io/</a></li></ul><hr><h2 id="5-更换主题"><a href="#5-更换主题" class="headerlink" title="5. 更换主题"></a><strong>5. 更换主题</strong></h2><h3 id="5-1-寻找主题"><a href="#5-1-寻找主题" class="headerlink" title="5.1 寻找主题"></a><strong>5.1 寻找主题</strong></h3><ul><li>既然默认主题很丑，那我们别的不做，首先来替换一个好看点的主题。</li><li>这是hexo官网：<a href="https://hexo.io/themes/%EF%BC%8C%E5%8F%AF%E5%9C%A8%E9%87%8C%E9%9D%A2%E4%B8%8B%E8%BD%BD%E4%B8%BB%E9%A2%98%EF%BC%8C%E7%82%B9%E5%87%BB%E4%B8%BB%E9%A2%98%E5%90%8D%E5%8D%B3%E5%8F%AF%E8%B7%B3%E8%BD%AC%E5%88%B0github%E4%B8%8A%EF%BC%8C%E4%B9%9F%E5%8F%AF%E4%BB%A5%E7%9B%B4%E6%8E%A5%E5%9C%A8github%E4%B8%8A%E6%90%9C%E7%B4%A2%E4%B8%BB%E9%A2%98">https://hexo.io/themes/，可在里面下载主题，点击主题名即可跳转到github上，也可以直接在github上搜索主题</a></li><li>在这里我使用github上一个大佬的主题blinkfox&#x2F;hexo-theme-matery</li></ul><p>​              链接：<a href="https://github.com/blinkfox/hexo-theme-matery">https://github.com/blinkfox/hexo-theme-matery</a>    </p><h3 id="5-2-下载主题"><a href="#5-2-下载主题" class="headerlink" title="5.2 下载主题"></a><strong>5.2 下载主题</strong></h3><p><strong>第一步：</strong>Git Bash Here中先cd到E:\xpzsData\hexocode目录</p><p><strong>第二步：</strong>再输入命令 $ git clone 主题http链接  themes&#x2F;主题名称</p><img src="/2024/03/24/hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/10.png" class="" title="img"><p><strong>注意：</strong></p><ul><li>E:\xpzsData\hexocode目录下的 theme 文件夹下存放的就是博客的主题，主题是否下载成功可到该目录下查看：</li></ul><img src="/2024/03/24/hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/11.png" class="" title="img"><h3 id="5-3-使用主题"><a href="#5-3-使用主题" class="headerlink" title="5.3 使用主题"></a><strong>5.3 使用主题</strong></h3><ul><li>打开E:\xpzsData\hexocode目录下的_config.yml文件，在里面找到theme: landscape改为theme: blinkfox   （blinkfox为我们要使用的主题名）,然后重新执行hexo g来重新生成。</li><li>如果出现一些莫名其妙的问题，可以先执行hexo clean来清理一下public的内容，然后再执行hexo g 和 hexo s 重新生成和发布。</li><li>再次在浏览器中输入对应域名, 即可发现主题已更换</li></ul><img src="/2024/03/24/hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/12.png" class="" title="img"><h3 id="5-4-修改主题内容"><a href="#5-4-修改主题内容" class="headerlink" title="5.4 修改主题内容"></a><strong>5.4 修改主题内容</strong></h3><p>在这里我使用的是blinkfox主题，后期相关修改参考这个主题文档</p><p><strong>文档链接：</strong><a href="https://github.com/blinkfox/hexo-theme-matery/blob/develop/README_CN.md">https://github.com/blinkfox/hexo-theme-matery/blob/develop/README_CN.md</a></p><ul><li>注意：一些非md文件可以把他们放到source文件夹下，这里的所有文件都会原样复制（除了md文件）到public目录的</li><li>大致在下图的文件夹里面修改文件，记得修改后的文件需要关闭后，再在hexocode根目录右键打开Git Bash  Here，输入两个命令：hexo g 重新生成，hexo s 开启本地预览服务,等修改的符合要求了，再输入 hexo d  推送到github仓库即可</li><li>这样就可以输入网址查看更改后的内容了</li></ul><img src="/2024/03/24/hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/13.png" class="" title="img"><p><strong>文档上没有提及的修改：</strong></p><ul><li>返回按钮样式修改：在主题下面的 blinkfox\layout_partial 文件夹中的 back-top.esj 文件中修改</li></ul><p><strong>特别注意：</strong></p><ul><li><strong>修改生成的默认页面信息，要到主题下面的_config.yml文件里面去改，而不是根目录下的_config.yml文件</strong></li></ul><img src="/2024/03/24/hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/14.png" class="" title="img"><ul><li><strong>要把根目录下的_config.yml文件中的这些信息替换成自己的和设置中文</strong></li></ul><img src="/2024/03/24/hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/15.png" class="" title="img"><h3 id="5-5-blinkfox主题的相关配置问题"><a href="#5-5-blinkfox主题的相关配置问题" class="headerlink" title="5.5 blinkfox主题的相关配置问题"></a><strong>5.5 blinkfox主题的相关配置问题</strong></h3><p><strong>配置音乐播放器：</strong>使用网易云音乐id不行，这里用的是QQ音乐</p><p><strong>配置留言功能（利用Valine）：</strong></p><ul><li>我们的评论系统其实是放在Leancloud上的，因此首先需要去注册一个账号</li><li>注册完以后需要创建一个应用，名字可以随便起，然后 进入应用-&gt;设置-&gt;应用key，获取你的appid 和 appkey，复制到主题下面的 _config.yml 文件里面搜索 valine，填入appid 和 appkey</li><li>最后！记得在Leancloud -&gt; 设置 -&gt; 安全中心 -&gt; Web 安全域名 把你的域名加进去就可以了</li><li>主题页面显示的内容在主题下面的 layout 文件夹中的 contact.ejs 文件里面更改</li></ul><hr><h2 id="6-利用Typora软件来写博客"><a href="#6-利用Typora软件来写博客" class="headerlink" title="6.利用Typora软件来写博客"></a><strong>6.利用Typora软件来写博客</strong></h2><h3 id="6-1-Typora介绍"><a href="#6-1-Typora介绍" class="headerlink" title="6.1 Typora介绍"></a><strong>6.1 Typora介绍</strong></h3><ul><li>Typora–一款简单高效的Markdown编辑器，保存后直接为md格式，Markdown中点击导入就可以。</li><li>Markdown是一种可以使用普通文本编辑器编写的标记语言，通过简单的标记语法，它可以使普通文本内容具有一定的格式，其目标是实现易读易写，说人话就是删减版的HTML语言</li><li>Markdown教程：<a href="https://www.runoob.com/markdown/md-tutorial.html">https://www.runoob.com/markdown/md-tutorial.html</a></li></ul><h3 id="6-2-安装Typora"><a href="#6-2-安装Typora" class="headerlink" title="6.2 安装Typora"></a><strong>6.2 安装Typora</strong></h3><p><strong>官网：</strong><a href="https://www.typora.io/#windows">https://www.typora.io/#windows</a></p><h3 id="6-3-写博客的步骤"><a href="#6-3-写博客的步骤" class="headerlink" title="6.3  写博客的步骤"></a><strong>6.3  写博客的步骤</strong></h3><p><strong>第一步：创建.md文件</strong></p><ul><li><strong>方法1：</strong>定位到我们的hexo根目录，Git Bash Here 中执行命令：  hexo new  ‘my-first-blog’                 hexo会帮我们在E:\xpzsData\hexocode\source_posts  下生成相关.md文件，用这个命令的好处是帮我们自动生成了时间，方法1默认生成如下内容：</li></ul><img src="/2024/03/24/hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/16.png" class="" title="img"><ul><li><strong>方法2：</strong>当然你也可以直接自己打开E:\xpzsData\hexocode\source_posts 目录新建.md文件</li></ul><p><strong>第二步：编写并保存</strong></p><p>我们只需要用typora打开这个文件就可以开始写博客了，写完后Ctrl+S 保存关闭即可</p><p><strong>第三步：</strong>清理然后再生成一下，生成后推送到远程仓库即可，hexo根目录下右键Git Bash Here 中依次输入如下命令：</p><ol><li>hexo clean</li><li>hexo g </li><li>hexo d</li></ol><p><strong>补充：</strong>hexo new page ‘postName’命令和hexo new ‘postName’的区别？</p><ul><li>hexo new page ‘My-second-blog’最终部署时生成：hexo\public\my-second-blog\index.html，但是它不会作为文章出现在博文目录。</li></ul><h3 id="6-4-Typora快捷键"><a href="#6-4-Typora快捷键" class="headerlink" title="6.4  Typora快捷键"></a><strong>6.4  Typora快捷键</strong></h3><p>Typora中只要记住一些基本的快捷键就可以了，所有功能软件里面都有对应按钮，这点不用慌。</p><p><strong>快捷键文章：</strong><a href="https://blog.csdn.net/weixin_39533052/article/details/111115263">https://blog.csdn.net/weixin_39533052/article/details/111115263</a></p><h3 id="6-5-注意：所使用的主题的文章-Front-matter-语法"><a href="#6-5-注意：所使用的主题的文章-Front-matter-语法" class="headerlink" title="6.5  注意：所使用的主题的文章 Front-matter 语法"></a><strong>6.5  注意：所使用的主题的文章 Front-matter 语法</strong></h3><p>依据使用的不同主题，一些文章功能所使用的语法可能不一样，例如写博客时给文章添加标签的语法等等，这些都要看所使用的主题的文档，例如我们这里使用的是 <strong>blinkfox</strong> 主题，打开主题文档，往下翻找到<strong>”</strong>  <strong>文章 Front-matter 介绍 “</strong>即可。</p><p><strong>blinkfox主题文档：</strong><a href="https://github.com/blinkfox/hexo-theme-matery/blob/develop/README_CN.md#%E6%96%87%E7%AB%A0-front-matter-%E4%BB%8B%E7%BB%8D">https://github.com/blinkfox/hexo-theme-matery/blob/develop/README_CN.md#%E6%96%87%E7%AB%A0-front-matter-%E4%BB%8B%E7%BB%8D</a></p><img src="/2024/03/24/hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/17.png" class="" title="img"><p><strong>示例：</strong></p><img src="/2024/03/24/hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/18.png" class="" title="img"><h3 id="6-6-YAML语法（了解）"><a href="#6-6-YAML语法（了解）" class="headerlink" title="6.6 YAML语法（了解）"></a><strong>6.6 YAML语法（了解）</strong></h3><p>像在typora中添加tags时，可以直接用数组的写法，也可以使用YAML语法，如下：</p><img src="/2024/03/24/hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/19.png" class="" title="img"><p><strong>YAML教程链接：</strong><a href="https://www.runoob.com/w3cnote/yaml-intro.html">https://www.runoob.com/w3cnote/yaml-intro.html</a></p><hr><h2 id="7-如何向hexo博客中插入图片"><a href="#7-如何向hexo博客中插入图片" class="headerlink" title="7.如何向hexo博客中插入图片"></a><strong>7.如何向hexo博客中插入图片</strong></h2><h3 id="7-1-使用相对路径的方式"><a href="#7-1-使用相对路径的方式" class="headerlink" title="7.1 使用相对路径的方式"></a><strong>7.1 使用相对路径的方式</strong></h3><p>众所周知，在md文件中插入图片的语法为!&#x2F;。</p><p>其中<strong>方括号</strong>是图片描述，<strong>圆括号</strong>是图片路径。</p><p>一般来说有三种图片路径，分别是<strong>相对路径，绝对路径和网络路径</strong>。</p><p>所谓的网络路径就是直接引用网上的图片，直接复制图片地址，放在圆括号中就完事了。</p><p>这种方式十分的方便，但是也存在一定的问题：</p><ul><li>图片失效导致无法加载；</li><li>打开网页后要再请求加载图片；</li><li>原网站限制，如微信公众号的图片会变得不可见等。</li></ul><p>这种方式算是有利有弊。</p><p>绝对路径是图片在计算机中的绝对位置，相对路径是相对于当前文件的路径。</p><p>由于我们的博客是要部署在网站上，部署后会生成新的文件目录，所以我们选择使用相对路径的方式。</p><p>在hexo中使用<strong>文章资源文件夹</strong>需要在config.yaml文件中更改一下配置：</p><p>post_asset_folder: true</p><p>当该配置被应用后，使用hexo new命令创建新文章时，会生成相同名字的文件夹，也就是文章资源文件夹。</p><img src="/2024/03/24/hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/replenish1.jpg" class="" title="img"><p>虽然可以正常引用图片了，但是这种引用图片的方式只有一句话能形容，wtf。</p><h3 id="7-2-hexo-renderer-marked插件的安装与配置"><a href="#7-2-hexo-renderer-marked插件的安装与配置" class="headerlink" title="7.2 hexo-renderer-marked插件的安装与配置"></a><strong>7.2 hexo-renderer-marked插件的安装与配置</strong></h3><p>插件<a href="https://github.com/hexojs/hexo-renderer-marked">hexo-renderer-marked</a>解决了这个问题</p><p><strong>安装：</strong>npm install hexo-image-link –save  ，之后在config.yaml中更改配置如下：</p><img src="/2024/03/24/hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/20.png" class="" title="img"><p>之后就可以愉快的插入图片了</p><h3 id="7-3-hexo-renderer-marked插件与Typora的完美结合"><a href="#7-3-hexo-renderer-marked插件与Typora的完美结合" class="headerlink" title="7.3 hexo-renderer-marked插件与Typora的完美结合"></a><strong>7.3 hexo-renderer-marked插件与Typora的完美结合</strong></h3><p>如果图片数量众多的话，一张一张的放很影响效率。但是不用怕，我们有很方便的解决方法。</p><p><strong>Typora</strong>是我非常喜欢的Markdown文本编辑器，在之前的文章中也介绍过一点。</p><p>Typora对于插入图片的支持做得非常好，在文件-&gt;偏好设置或者直接&lt;C-,&gt;进入设置。</p><img src="/2024/03/24/hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/21.png" class="" title="img"><p><strong>复制网络路径的图片：</strong></p><p>使用该配置后，可以直接复制网页中的图片地址，粘贴到Typora中后，会直接复制该图片到文章资源文件夹，同时自动更改路径。</p><p>如复制网络路径的图片https:&#x2F;&#x2F;…..&#x2F;image.jpg粘贴到Typora中叫文章名的文章后，图片会自动变为(文章名&#x2F;image.jpg)。</p><p>但我们知道部署后，文件路径是不同的，所以当我们插入完所有的图片后，我们还需要删除每个图片路径中的文件名&#x2F;。不慌，也很简单。</p><p>在Typora编辑器中，使用快捷键，将所有的文章名&#x2F;替换为空即可删除。</p><img src="/2024/03/24/hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/22.png" class="" title="img"><p>然后再将博客上传，图片就会随着文章一起打包。在网页中就可以看到正常显示的图片，大功告成</p><hr><h2 id="8-总结"><a href="#8-总结" class="headerlink" title="8.总结"></a>8.总结</h2><p>这是本人搭建博客过程中遇到的一些问题和解决办法，按照我这个步骤基本就能搭建起来一个不错的博客了，文章里面省略了博客的SEO优化，比如让百度和谷歌搜索引擎收录我们的博客网站，这点大家可以去网上搜索，教程很多的，有什么问题欢迎在下方留言！</p><p>参考文献：</p><p>1：<a href="https://github.com/blinkfox/hexo-theme-matery/blob/develop/README_CN.md">https://github.com/blinkfox/hexo-theme-matery/blob/develop/README_CN.md</a></p><p>2：<a href="https://www.cnblogs.com/liuxianan/p/build-blog-website-by-hexo-github.html">https://www.cnblogs.com/liuxianan/p/build-blog-website-by-hexo-github.html</a></p><p>3：<a href="https://www.jianshu.com/p/f72aaad7b852">https://www.jianshu.com/p/f72aaad7b852</a></p>]]></content>
      
      
      <categories>
          
          <category> 博客搭建 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 个人博客 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>大数据</title>
      <link href="/2024/03/24/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
      <url>/2024/03/24/%E5%A4%A7%E6%95%B0%E6%8D%AE/</url>
      
        <content type="html"><![CDATA[<h2 id="1-TopK问题"><a href="#1-TopK问题" class="headerlink" title="1.TopK问题"></a>1.TopK问题</h2><h3 id="1-1一类问题"><a href="#1-1一类问题" class="headerlink" title="1.1一类问题"></a>1.1一类问题</h3><ol><li>1亿个浮点数，如果找出最⼤的10000个</li><li>有⼀个<strong>1G</strong>⽂件，内存限制⼤⼩是<strong>1M</strong>。返回频数最⾼<strong>100</strong></li><li>100w个数中找出最⼤的100个数</li><li>海量数据分布在<strong>100</strong>台电脑中，想个办法⾼校统计出这批数据的<strong>TOP10</strong></li><li>海量⽇志数据，提取出某⽇访问百度次数最多的那个<strong>IP</strong></li><li>⼀个亿级⽂本⽂件，找出前<strong>10</strong>个经常出现的词，⽆法⼀次读⼊内存，问最优解</li><li>怎么在海量数据中找出重复次数最多的⼀个</li><li>上千万或上亿数据（有重复），统计其中出现次数最多的前N个数据。</li></ol><p>解法：hash+分治+⼩顶堆+hashmap统计次数+快速排序思想+插入排序思想</p><ol><li><p>hash去重：</p><p>如果这1亿个书⾥⾯有很多重复的数，先通过Hash法，把这1亿个数字去重复，这样如果重复率很⾼的话，会减少很⼤的内存⽤量，从⽽缩⼩运算空间，然后通过分治法或最⼩堆法查找最⼤的10000个数</p></li><li><p>划分文件：</p><p>⽐如模1000，把整个⼤⽂件映射为1000个⼩⽂件，并且相同的数一定在一个文件中</p></li><li><p>分治：</p><p>顺序读⽂件中，对于每个词x，取 ，然后按照该值存到5000个⼩⽂件（记为）中。这样每个⽂件⼤概是200k左右。如果其中的有的⽂件超过了1M⼤⼩，还可以按照类似的⽅法继续往下分，直到分解得到的⼩⽂件的⼤⼩都不超过1M</p></li><li><p>⼩顶堆：</p><p>⾸先读⼊前10000个数来创建⼤⼩为10000的最⼩堆，建堆的时间复杂度为O（mlogm）（m为数组的⼤⼩即为10000），然后遍历后续的数字，并于堆顶（最⼩）数字进⾏⽐较。如果⽐最⼩的数⼩，则继续读取后续数字；如果⽐堆顶数字⼤，则替换堆顶元素并重新调整堆为最⼩堆。整个过程直⾄1亿个数全部遍历完为⽌。然后按照中序遍历的⽅式输出当前堆中的所有10000个数字。该算法的时间复杂度为O（nmlogm），空间复杂度是10000（常数）</p></li><li><p>快速排序思想：</p><p>100万个数据⾥⾯查找最⼤的10000个数据的⽅法如下：⽤快速排序的⽅法，将数据分为2堆，如果⼤的那堆个数N⼤于10000个，继续对⼤堆快速排序⼀次分成2堆，如果⼤的那堆个数N⼤于10000个，继续对⼤堆快速排序⼀次分成2堆，如果⼤堆个数N⼩于10000个，就在⼩的那堆⾥⾯快速排序⼀次，找第10000-n⼤的数字；递归以上过程，就可以找到第1w⼤的数。参考上⾯的找出第1w⼤数字，就可以类似的⽅法找到前10000⼤数字了。此种⽅法需要每次的内存空间为10^6*4&#x3D;4MB，⼀共需要101次这样的⽐较。</p></li><li><p>插入排序思想：</p><p>采⽤局部淘汰法。选取前100个元素，并排序，记为序列L。然后⼀次扫描剩余的元素x，与排好序的100个元素中最⼩的元素⽐，如果⽐这个最⼩的要⼤，那么把这个最⼩的元素删除，并把x利⽤插⼊排序的思想，插⼊到序列L中。依次循环，直到扫描了所有的元素。复杂度为O(100w*100)。 这个⽅法就是插⼊排序。</p></li></ol><h3 id="1-2万级文本文件，每行一个词，统计出其中最频繁出现的前10个词"><a href="#1-2万级文本文件，每行一个词，统计出其中最频繁出现的前10个词" class="headerlink" title="1.2万级文本文件，每行一个词，统计出其中最频繁出现的前10个词"></a>1.2万级文本文件，每行一个词，统计出其中最频繁出现的前10个词</h3><p>这题是考虑时间效率。<u>用trie树统计每个词出现的次数</u>，时间复杂度是O(n<em>le)（le表示单词的平准长度）。然后是找出出现最频繁的前10个词，可以用堆来实现，前面的题中已经讲到了，时间复杂度是O(n</em>lg10)。所以总的时间复杂度，是O(n<em>le)与O(n</em>lg10)中较大的哪一个。</p><h3 id="1-3最热门的10个查询串"><a href="#1-3最热门的10个查询串" class="headerlink" title="1.3最热门的10个查询串"></a>1.3最热门的10个查询串</h3><p>搜索引擎会通过日志文件把用户每次检索使用的所有检索串都记录下来，每个查询串的长度为1-255字节。假设目前有一千万个记录，这些查询串的重复读比较高，虽然总数是1千万，但是如果去除重复和，不超过3百万个。一个查询串的重复度越高，说明查询它的用户越多，也就越热门。</p><p>请你统计最热门的10个查询串，要求使用的内存不能超过1G。</p><p>(1) 请描述你解决这个问题的思路；</p><p>(2) 请给出主要的处理流程，算法，以及算法的复杂度。</p><p>方案1：采用trie树，关键字域存该查询串出现的次数，没有出现为0。最后用10个元素的最小推来对出现频率进行排序。</p><p>方案2：可以采用hash分块，然后统计各个块中的最热门的10个查询，然后用堆排序，时间复杂度&#x3D;N+n<em>m +nlog10 +m</em>10log10.此可以用来处理超过内存容量的情况 </p><h3 id="1-4找出出现次数最多的IP"><a href="#1-4找出出现次数最多的IP" class="headerlink" title="1.4找出出现次数最多的IP"></a>1.4找出出现次数最多的IP</h3><p>可以考虑采用“分而治之”的思想，按照IP地址的Hash(IP)%1024值，把海量IP日志分别存储到1024个小文件中。</p><h2 id="2-重复问题"><a href="#2-重复问题" class="headerlink" title="2.重复问题"></a>2.重复问题</h2><h3 id="2-1⽂件包含电话号码，统计不同号码的个数"><a href="#2-1⽂件包含电话号码，统计不同号码的个数" class="headerlink" title="2.1⽂件包含电话号码，统计不同号码的个数"></a>2.1⽂件包含电话号码，统计不同号码的个数</h3><p>对于本题，8 位电话号码可以表示的号码个数为 10^8 个，即 1 亿个。我们每个号码用一个 bit 来表示，则总共需要 1 亿个 bit，内存占用约 100M。</p><p>思路如下：</p><p>申请一个位图数组，长度为 1 亿，初始化为 0。然后遍历所有电话号码，把号码对应的位图中的位置置为 1。遍历完成后，如果 bit 为 1，则表示这个电话号码在文件中存在，否则不存在。bit 值为 1 的数量即为 不同电话号码的个数。</p><h3 id="2-2在2-5亿个整数中找出不重复的整数，内存不⾜以容纳这2-5亿个整数。"><a href="#2-2在2-5亿个整数中找出不重复的整数，内存不⾜以容纳这2-5亿个整数。" class="headerlink" title="2.2在2.5亿个整数中找出不重复的整数，内存不⾜以容纳这2.5亿个整数。"></a>2.2在2.5亿个整数中找出不重复的整数，内存不⾜以容纳这2.5亿个整数。</h3><p>方案1：采用2-Bitmap（每个数分配2bit，00表示不存在，01表示出现一次，10表示多次，11无意义）进行，共需内存内存（整数占4B，32位），还可以接受。然后扫描这2.5亿个整数，查看Bitmap中相对应位，如果是00变01，01变10，10保持不变。所描完事后，查看bitmap，把对应位是01的整数输出即可。</p><p>方案2：也可采用上题类似的方法，进行划分小文件的方法。然后在小文件中找出不重复的整数（用hashset和hashmap，trie树对hashmap的优势是，在大量重复的单词中，trie树需要的内存会低一些，hashmap的优势是查找快一些。），并排序。然后再进行归并，注意去除重复的元素。也可像鸽巢原理，整数个数为2^32,也就是，我们可以将这2^32个数，划分为2^8个区域(比如用单个文件代表一个区域)，然后将数据分离到不同的区域，然后不同的区域在利用bitmap就可以直接解决了。也就是说只要有足够的磁盘空间，就可以很方便的解决。</p><h3 id="2-31000万字符串，去重"><a href="#2-31000万字符串，去重" class="headerlink" title="2.31000万字符串，去重"></a>2.31000万字符串，去重</h3><p>这题⽤trie树⽐较合适，hash_map也应该能⾏。</p><h2 id="3-排序问题"><a href="#3-排序问题" class="headerlink" title="3.排序问题"></a>3.排序问题</h2><h3 id="3-1一个文件中有9亿条不重复的9位整数-对这个文件中数字进行排序"><a href="#3-1一个文件中有9亿条不重复的9位整数-对这个文件中数字进行排序" class="headerlink" title="3.1一个文件中有9亿条不重复的9位整数,对这个文件中数字进行排序;"></a>3.1一个文件中有9亿条不重复的9位整数,对这个文件中数字进行排序;</h3><p>解决思路：</p><p>（❌）将所有数据<strong>导入到内存</strong>中,然后使用常规的排序方法,例如插入排序,快速排序,归并排序等各种排序方法对数据进行排序,最后将排序好的数据存入文件.但这些方法在此并不适用,由于数据量巨大,对32位机器而言,很难将这么多数据一次载入到内存,更不用说进行排序了.所以此种方法一般不可行,需要考虑其他方法.     ————————————————</p><ol><li>方法一：数据库排序法.<br>     将文本文件导入到数据库中,让文本文件导入到数据库中,让数据库进行索引排序操作后提取数据到文件.该种方法虽然操作简单,方便,但是运算速度较慢,而且对数据库设备要求比较高.</li><li>方法二：分治法.<br>      通过Hash法将9亿条数据分为20段,每一段大约5000万条,大约需要占用500万*4B &#x3D; 200MB空间,在文件中依次搜索0<del>5000万,50000001</del>1亿  ,,将排序的结果存入文件,该方法要装满9位整数,一共需要20次,所以一共要进行20次排序,需要对文件进行20次读操作.该方法虽然缩小了每次使用的内存空间大小,但是编码复杂,速度也慢.</li><li>方法三：位图法.<br>       考虑到最大的9位整数为999999999,由于9亿条数据是不重复的,可以把这些数据组成一个队列或者数组,让它有0~999999999(一共10亿个数)元素数组下标表示数值,结点中用0表示没有这个数,1表示存在这个数,判断0或1只用一个bit存储就够了,<br>      而声明一个可以包含9位整数的bit数组,一共需要10亿&#x2F;8,大约120MB内存,把内存中的数组全部初始化为0,读取文件中的数据,并将数据放入内存.比如读到一个数据为314332897这个数据,那就先在内存中找到314332897这个bit,并将bit值置为1,遍历整个bit数组,将bit为1的数组下标存入文件,最终得到排序的内容.</li></ol><p>外排序：</p><p>外部排序算法由两个阶段构成：</p><ol><li>按照内存大小，将大文件分成若干长度为     l 的子文件（l     应小于内存的可使用容量），然后将各个子文件依次读入内存，使用适当的内部排序算法对其进行排序（排好序的子文件统称为“归并段”或者“顺段”），将排好序的归并段重新写入外存，为下一个子文件排序腾出内存空间；</li><li>对得到的顺段进行合并，直至得到整个有序的文件为止。</li></ol><p>注意：在实际归并的过程中，由于内存容量的限制不能满足同时将 2 个归并段全部完整的读入内存进行归并，只能不断地取 2 个归并段中的每一小部分进行归并，通过不断地读数据和向外存写数据，直至 2 个归并段完成归并变为 1 个大的有序文件。</p><p><a href="http://data.biancheng.net/view/76.html">http://data.biancheng.net/view/76.html</a></p><h3 id="3-2频度排序"><a href="#3-2频度排序" class="headerlink" title="3.2频度排序"></a>3.2频度排序</h3><p><strong>题目： 有10个文件，每个文件1G，每个文件的每一行存放的都是用户的query，每个文件的query都可能重复。要求你按照query的频度排序</strong></p><p>方案1：</p><p> - 顺序读取10个文件，按照hash(query)%10的结果将query写入到另外10个文件中。这样新生成的文件每个的大小大约也1G（假设hash函数是随机的）。</p><p> -找一台内存在2G左右的机器，依次对用hash_map(query, query_count)来统计每个query出现的次数。利用快速&#x2F;堆&#x2F;归并排序按照出现次数进行排序。将排序好的query和对应的query_cout输出到文件中。这样得到了10个排好序的文件。</p><p>  -对这10个文件进行归并排序（内排序与外排序相结合）。</p><p>方案2：</p><p>一般query的总量是有限的，只是重复的次数比较多而已，可能对于所有的query，一次性就可以加入到内存了。这样，我们就可以采用trie树&#x2F;hash_map等直接来统计每个query出现的次数，然后按出现次数做快速&#x2F;堆&#x2F;归并排序就可以了。</p><p>方案3：</p><p>与方案1类似，但在做完hash，分成多个文件后，可以交给多个文件来处理，采用分布式的架构来处理（比如MapReduce），最后再进行合并。（与1相比就是处理构架不同）</p><h2 id="4相等问题"><a href="#4相等问题" class="headerlink" title="4相等问题"></a>4相等问题</h2><h3 id="4-1两文件，如何从-100-亿-URL-中找出相同的-URL？"><a href="#4-1两文件，如何从-100-亿-URL-中找出相同的-URL？" class="headerlink" title="4.1两文件，如何从 100 亿 URL 中找出相同的 URL？"></a>4.1两文件，如何从 100 亿 URL 中找出相同的 URL？</h3><p><strong>Eg： 给定 a、b 两个文件，各存放 50 亿个 URL，每个 URL 各占 64B，内存限制是 4G。请找出 a、b 两个文件共同的 URL。</strong></p><p>每个 URL 占 64B，那么 50 亿个 URL 占用的空间大小约为 320GB。由于内存大小只有 4G，因此，我们不可能一次性把所有 URL 加载到内存中处理。</p><ol><li><p>分治：把一个文件中的 URL 按照某个特征划分为多个小文件，使得每个小文件大小不超过 4G，这样就可以把这个小文件读到内存中进行处理了。</p><p>首先遍历文件 a，对遍历到的 URL 求 hash(URL) % 1000 ，根据计算结果把遍历到的 URL 存储到 a0, a1, a2, …, a999，这样每个大小约为 300MB。使用同样的方法遍历文件 b，把文件 b 中的 URL 分别存储到文件 b0, b1, b2, …, b999 中。这样处理过后，所有可能相同的 URL 都在对应的小文件中，即 a0 对应 b0, …, a999 对应 b999，不对应的小文件不可能有相同的 URL。那么接下来，我们只需要求出这 1000 对小文件中相同的 URL 就好了。</p></li><li><p>hash: 对每个子文件做hashset统计</p><p>接着遍历 ai( i∈[0,999] )，把 URL 存储到一个 HashSet 集合中。然后遍历 bi 中每个 URL，看在 HashSet 集合中是否存在，若存在，说明这就是共同的 URL，可以把这个 URL 保存到一个单独的文件中。</p></li><li><p>Bloom filter</p></li></ol><p>  如果允许有一定的错误率，可以使用Bloom filter，4G内存大概可以表示340亿bit。将其中一个文件中的url使用Bloom filter映射为这340亿bit，然后挨个读取另外一个文件的url，检查是否与Bloom filter，如果是，那么该url应该是共同的url（注意会有一定的错误率）。</p><h2 id="5-中位数问题"><a href="#5-中位数问题" class="headerlink" title="5.中位数问题"></a>5.中位数问题</h2><h3 id="5-1查找中位数"><a href="#5-1查找中位数" class="headerlink" title="5.1查找中位数"></a>5.1查找中位数</h3><p>方法一：</p><p>分治法的思想是把一个大的问题逐渐转换为规模较小的问题来求解。</p><p>对于这道题，顺序读取这 5 亿个数字，对于读取到的数字 num，如果它对应的二进制中最高位为 1，则把这个数字写到 f1 中，否则写入 f0 中。通过这一步，可以把这 5 亿个数划分为两部分，而且 f0 中的数都大于 f1 中的数（最高位是符号位）。</p><p>划分之后，可以非常容易地知道中位数是在 f0 还是 f1 中。假设 f1 中有 1 亿个数，那么中位数一定在 f0 中，且是在 f0 中，从小到大排列的第 1.5 亿个数与它后面的一个数的平均值。</p><p>提示，5 亿数的中位数是第 2.5 亿与右边相邻一个数求平均值。若 f1 有一亿个数，那么中位数就是 f0 中从第 1.5 亿个数开始的两个数求得的平均值。</p><p>对于 f0 可以用次高位的二进制继续将文件一分为二，如此划分下去，直到划分后的文件可以被加载到内存中，把数据加载到内存中以后直接排序，找出中位数。</p><p>注意，当数据总数为偶数，如果划分后两个文件中的数据有相同个数，那么中位数就是数据较小的文件中的最大值与数据较大的文件中的最小值的平均值。</p><p>方法二：</p><p>排序后找。</p><p><a href="https://zhuanlan.zhihu.com/p/75397875%E6%96%B9%E6%B3%95%E6%9B%B4%E5%A4%9A%EF%BC%8C%E6%9B%B4%E8%AF%A6%E7%BB%86">https://zhuanlan.zhihu.com/p/75397875方法更多，更详细</a></p><h3 id="5-2N个机器，如何找到中位数"><a href="#5-2N个机器，如何找到中位数" class="headerlink" title="5.2N个机器，如何找到中位数"></a>5.2N个机器，如何找到中位数</h3><p>题目限制：每个机器上有N个数。每个机器最多存O(N)个数并对它们操作。 </p><p><img src="C:\Users\hasee\Downloads\GetImage.png" alt="GetImage"></p><h2 id="6-随机选择K个数—蓄水池采样"><a href="#6-随机选择K个数—蓄水池采样" class="headerlink" title="6.随机选择K个数—蓄水池采样"></a>6.随机选择K个数—蓄水池采样</h2><p>问题：</p><p>“给出一个数据流，这个数据流的长度很大或者未知。并且对该数据流中数据只能访问一次。请写出一个随机选择算法，使得数据流中所有数据被选中的概率相等。”</p><p>解法：</p><p><strong>蓄水池采样（Reservoir Sampling）算法。</strong></p><p>介绍该算法之前，我们首先从最简单的例子出发（只在数据流中取一个数据）：假设数据流只有一个数据。我们接收数据，发现数据流结束了，直接返回该数据，该数据返回的概率为1。看来很简单，那么我们试试难一点的情况：假设数据流里有两个数据。</p><p>我们读到了第一个数据，这次我们不能直接返回该数据，因为数据流没有结束。我们继续读取第二个数据，发现数据流结束了。因此我们只要保证以相同的概率返回第一个或者第二个数据就可以满足题目要求。因此我们生成一个0到1的随机数R，如果R小于0.5，我们就返回第一个数据，如果R大于0.5，返回第二个数据。</p><p>接着我们继续分析有三个数据的数据流的情况。为了方便，我们按顺序给流中的数据命名为1、2、3。我们陆续收到了数据1、2。和前面的例子一样，我们只能保存一个数据，所以必须淘汰1和2中的一个。应该如何淘汰呢？不妨和上面例子一样，我们按照二分之一的概率淘汰一个，例如我们淘汰了2。继续读取流中的数据3，发现数据流结束了，我们知道在长度为3的数据流中，如果返回数据3的概率为1&#x2F;3，那么才有可能保证选择的正确性。也就是说，目前我们手里有1、3两个数据，我们通过一次随机选择，以1&#x2F;3的概率留下数据3，以2&#x2F;3的概率留下数据1。那么数据1被最终留下的概率是多少呢？</p><p>数据1被留下概率：（1&#x2F;2）* (2&#x2F;3) &#x3D; 1&#x2F;3</p><p>数据2被留下概率：（1&#x2F;2）*(2&#x2F;3) &#x3D; 1&#x2F;3</p><p>数据3被留下概率：1&#x2F;3</p><p>这个方法可以满足题目要求，所有数据被留下返回的概率一样。</p><p><u>因此，循着这个思路，我们可以总结算法的过程</u>：</p><p>假设需要采样的数量为K。</p><p>1、首先构建一个可容纳 K 个元素的数组，将序列的前 K 个元素放入数组中。</p><p>2、对于第 i&gt;&#x3D;k+1，我们以 k&#x2F;i 概率决定是否要把它换入蓄水池，换入时随机的选取一个作为替换项，这样一直做下去，对于任意的样本空间n，对每个数的选取概率都为k&#x2F;n。也就是说对每个数选取概率相等。 当遍历完所有元素之后，数组中剩下的元素即为所需采取的样本。</p><p>代码如下：<img src="/2024/03/24/%E5%A4%A7%E6%95%B0%E6%8D%AE/%E4%BB%A3%E7%A0%81.png" class="" title="GetImage(1)"></p><img src="/2024/03/24/%E5%A4%A7%E6%95%B0%E6%8D%AE/%E4%BB%A3%E7%A0%81%E8%A7%A3%E8%AF%BB.png" class="" title="GetImage(2)">]]></content>
      
      
      <categories>
          
          <category> java面经 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java面试 </tag>
            
            <tag> 大数据 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
