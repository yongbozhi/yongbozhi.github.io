<!DOCTYPE HTML>
<html lang="zh-CN">


<head>
    <meta charset="utf-8">
    <meta name="keywords" content="计算机网络, 小智同学的blog">
    <meta name="description" content="7层模型
应⽤层 
应⽤层(application-layer）的任务是通过应⽤进程间的交互来完成特定⽹络应⽤。应⽤层协议定义的是应⽤进程（进程：主机中正在运⾏的程序）间的通信和交互的规则。对于不同的⽹络应⽤需要不同的应⽤层协议。在互联⽹中">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="referrer" content="no-referrer-when-downgrade">
    <!-- Global site tag (gtag.js) - Google Analytics -->


    <title>计算机网络 | 小智同学的blog</title>
    <link rel="icon" type="image/jpeg" href="/favicon.jpg">
    


    <!-- bg-cover style     -->



<link rel="stylesheet" type="text/css" href="/libs/awesome/css/all.min.css">
<link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css">
<link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
<link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
<link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
<link rel="stylesheet" type="text/css" href="/css/matery.css">
<link rel="stylesheet" type="text/css" href="/css/my.css">
<link rel="stylesheet" type="text/css" href="/css/dark.css" media="none" onload="if(media!='all')media='all'">




    <link rel="stylesheet" href="/libs/tocbot/tocbot.css">
    <link rel="stylesheet" href="/css/post.css">




    
        <link rel="stylesheet" type="text/css" href="/css/reward.css">
    



    <script src="/libs/jquery/jquery-3.6.0.min.js"></script>

<meta name="generator" content="Hexo 7.1.1"><link rel="alternate" href="/atom.xml" title="小智同学的blog" type="application/atom+xml">
<link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css"></head>


<body>
    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="/medias/logo.jpg" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">小智同学的blog</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a>
<ul class="right nav-menu">
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/" class="waves-effect waves-light">
      
      <i class="fas fa-home" style="zoom: 0.6;"></i>
      
      <span>首页</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/tags" class="waves-effect waves-light">
      
      <i class="fas fa-tags" style="zoom: 0.6;"></i>
      
      <span>标签</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/categories" class="waves-effect waves-light">
      
      <i class="fas fa-bookmark" style="zoom: 0.6;"></i>
      
      <span>分类</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/archives" class="waves-effect waves-light">
      
      <i class="fas fa-archive" style="zoom: 0.6;"></i>
      
      <span>归档</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/about" class="waves-effect waves-light">
      
      <i class="fas fa-user-circle" style="zoom: 0.6;"></i>
      
      <span>关于</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/contact" class="waves-effect waves-light">
      
      <i class="fas fa-comments" style="zoom: 0.6;"></i>
      
      <span>留言板</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/friends" class="waves-effect waves-light">
      
      <i class="fas fa-address-book" style="zoom: 0.6;"></i>
      
      <span>友情链接</span>
    </a>
    
  </li>
  
  <li>
    <a href="#searchModal" class="modal-trigger waves-effect waves-light">
      <i id="searchIcon" class="fas fa-search" title="搜索" style="zoom: 0.85;"></i>
    </a>
  </li>
  <li>
    <a href="javascript:;" class="waves-effect waves-light" onclick="switchNightMode()" title="深色/浅色模式" >
      <i id="sum-moon-icon" class="fas fa-sun" style="zoom: 0.85;"></i>
    </a>
  </li>
</ul>


<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="/medias/logo.jpg" class="logo-img circle responsive-img">
        
        <div class="logo-name">小智同学的blog</div>
        <div class="logo-desc">
            
            Never really desperate, only the lost of the soul.
            
        </div>
    </div>

    <ul class="menu-list mobile-menu-list">
        
        <li class="m-nav-item">
	  
		<a href="/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-home"></i>
			
			首页
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/tags" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-tags"></i>
			
			标签
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/categories" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-bookmark"></i>
			
			分类
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/archives" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-archive"></i>
			
			归档
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/about" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-user-circle"></i>
			
			关于
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/contact" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-comments"></i>
			
			留言板
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/friends" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-address-book"></i>
			
			友情链接
		</a>
          
        </li>
        
        
        <li><div class="divider"></div></li>
        <li>
            <a href="https://github.com/blinkfox/hexo-theme-matery" class="waves-effect waves-light" target="_blank">
                <i class="fab fa-github-square fa-fw"></i>Fork Me
            </a>
        </li>
        
    </ul>
</div>


        </div>

        
            <style>
    .nav-transparent .github-corner {
        display: none !important;
    }

    .github-corner {
        position: absolute;
        z-index: 10;
        top: 0;
        right: 0;
        border: 0;
        transform: scale(1.1);
    }

    .github-corner svg {
        color: #0f9d58;
        fill: #fff;
        height: 64px;
        width: 64px;
    }

    .github-corner:hover .octo-arm {
        animation: a 0.56s ease-in-out;
    }

    .github-corner .octo-arm {
        animation: none;
    }

    @keyframes a {
        0%,
        to {
            transform: rotate(0);
        }
        20%,
        60% {
            transform: rotate(-25deg);
        }
        40%,
        80% {
            transform: rotate(10deg);
        }
    }
</style>

<a href="https://github.com/blinkfox/hexo-theme-matery" class="github-corner tooltipped hide-on-med-and-down" target="_blank"
   data-tooltip="Fork Me" data-position="left" data-delay="50">
    <svg viewBox="0 0 250 250" aria-hidden="true">
        <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path>
        <path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2"
              fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path>
        <path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z"
              fill="currentColor" class="octo-body"></path>
    </svg>
</a>
        
    </nav>

</header>

    



<div class="bg-cover pd-header post-cover" style="background-image: url('/medias/featureimages/9.jpg')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <h1 class="description center-align post-title">计算机网络</h1>
                </div>
            </div>
        </div>
    </div>
</div>




<main class="post-container content">

    
    <div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                    <div class="article-tag">
                        
                            <a href="/tags/java%E9%9D%A2%E8%AF%95/">
                                <span class="chip bg-color">java面试</span>
                            </a>
                        
                            <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">
                                <span class="chip bg-color">计算机网络</span>
                            </a>
                        
                    </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                    <div class="post-cate">
                        <i class="fas fa-bookmark fa-fw icon-category"></i>
                        
                            <a href="/categories/java%E9%9D%A2%E7%BB%8F/" class="post-category">
                                java面经
                            </a>
                        
                    </div>
                    
                </div>
            </div>

            <div class="post-info">
                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-minus fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2024-04-06
                </div>
                

                

                
                <div class="info-break-policy">
                    <i class="far fa-file-word fa-fw"></i>文章字数:&nbsp;&nbsp;
                    12.9k
                </div>
                

                
                <div class="info-break-policy">
                    <i class="far fa-clock fa-fw"></i>阅读时长:&nbsp;&nbsp;
                    46 分
                </div>
                

                
                    <div id="busuanzi_container_page_pv" class="info-break-policy">
                        <i class="far fa-eye fa-fw"></i>阅读次数:&nbsp;&nbsp;
                        <span id="busuanzi_value_page_pv"></span>
                    </div>
				
            </div>
        </div>
        <hr class="clearfix">

        

        

        <div class="card-content article-card-content">
            <div id="articleContent">
                <h1 id="7层模型"><a href="#7层模型" class="headerlink" title="7层模型"></a>7层模型</h1><ul>
<li><p>应⽤层 </p>
<p>应⽤层(application-layer）的任务是通过应⽤进程间的交互来完成特定⽹络应⽤。应⽤层协议定义的是应⽤进程（进程：主机中正在运⾏的程序）间的通信和交互的规则。对于不同的⽹络应⽤需要不同的应⽤层协议。在互联⽹中应⽤层协议很多，如域名系统DNS，⽀持万维⽹应⽤的<strong>HTTP协议，⽀持电⼦邮件的</strong> <strong>SMTP协议等等。我们把应⽤层交互的据单元称为报⽂。</strong> </p>
</li>
<li><p>运输层 </p>
<p>运输层**(transport layer)**的主要任务就是负责向两台主机进程之间的通信提供通⽤的数据传输服务。应⽤进程利⽤该服务传送应⽤层报⽂。“通⽤的”是指并不针对某⼀个特定的⽹络应⽤，⽽是 多种应⽤可以使⽤同⼀个运输层服务。由于⼀台主机可同时运⾏多个线程，因此运输层有复⽤和 分⽤的功能。所谓复⽤就是指多个应⽤层进程可同时使⽤下⾯运输层的服务，分⽤和复⽤相反， 是运输层把收到的信息分别交付上⾯应⽤层中的相应进程。 </p>
<p>运输层主要使⽤以下两种协议**:**</p>
<ol>
<li><p>传输控制协议 <strong>TCP</strong>（Transmission Control Protocol）–提供⾯向连接的，可靠的数据传输 服务。 </p>
</li>
<li><p>⽤户数据协议 <strong>UDP</strong>（User Datagram Protocol）–提供⽆连接的，尽最⼤努⼒的数据传输服 务（不保证数据传输的可靠性）</p>
</li>
</ol>
</li>
<li><p>⽹络层 </p>
<p>在计算机⽹络中进⾏通信的两个计算机之间可能会经过很多个数据链路，也可能还要经过很多通信⼦⽹。⽹络层的任务就是选择合适的⽹间路由和交换结点， 确保数据及时传送。在发送数据时，⽹络层把运输层产⽣的报⽂段或⽤户数据报封装成分组和包进⾏传送。</p>
</li>
<li><p>数据链路层 </p>
<p>数据链路层**(data link layer)**通常简称为链路层。两台主机之间的数据传输，总是在⼀段⼀段的链 路上传送的，这就需要使⽤专⻔的链路层的协议。 在两个相邻节点之间传送数据时，数据链路层 将⽹络层交下来的 <strong>IP</strong> 数据报组装成帧，在两个相邻节点间的链路上传送帧。每⼀帧包括数据和必要的控制信息（如同步信息，地址信息，差错控制等）。</p>
<p>⽹络并不是⼀个整体，⼀旦数据需要跨⽹络传输，就需要有⼀个设备同时在两个⽹络当中，这个设备⼀般是路由器，路由器可以通过路由 表计算出下⼀个要去的 IP 地址。 </p>
<p>那问题来了，路由器怎么知道这个 IP 地址是哪个设备的呢？ </p>
<p>于是，就需要有⼀个专⻔的层来标识⽹络中的设备，让数据在⼀个链路中传输，这就是数据链路层（<em>Data Link Layer</em>），它主要为⽹络层提供链路级别传的服务。</p>
</li>
<li><p>物理层 </p>
<p>在物理层上所传送的数据单位是⽐特。 </p>
<p>物理层**(physical layer)**的作⽤是实现相邻计算机节点之间⽐特流的透明传送，尽可能屏蔽掉具体传输介质和物理设备的差异。</p>
</li>
</ul>
<h1 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h1><h2 id="HTTP-是什么？描述⼀下"><a href="#HTTP-是什么？描述⼀下" class="headerlink" title="HTTP 是什么？描述⼀下"></a>HTTP 是什么？描述⼀下</h2><p>HTTP 是超⽂本传输协议，也就是Hyper TextTransfer Protocol。</p>
<p>HTTP的名字「超⽂本协议传输」，它可以拆成三个部分：超⽂本传输，协议</p>
<p>​	超⽂本：现在「⽂本」的涵义已经可以扩展为图⽚、视频、压缩包等，在 HTTP 眼⾥这些都算作「⽂本」。最关键有超链接，能从⼀个超⽂本跳转到另外⼀个超⽂本。HTML 就是最常⻅的超⽂本了，它本身只是纯⽂字⽂件，但内部⽤很多标签定义了图⽚、视频等的链接，再经过浏览器的解释，呈现给我们的就是⼀个⽂字、有画⾯的⽹⻚了。</p>
<p>​    传输：计算机世界⾥专⻔⽤来在两点之间传输数据的约定和规范，我们在上⽹冲浪时，浏览器是请求⽅ A ，百度⽹站就是应答⽅ B。双⽅约定⽤ HTTP 协议来通信，于是浏览器把请求数据发送给⽹站，⽹站再把⼀些数据返回给浏览器，最后由浏览器渲染在屏幕，就可以看到图⽚、视频了。</p>
<p>​    协议：计算机之间交流通信的规范（两个以上的参与者），以及相关的各种控制和错误处理⽅式（⾏为约定和规范）。数据虽然是在 A 和 B 之间传输，但允许中间有中转或接⼒。HTTP ⾥，需要中间⼈遵从 HTTP 协议，只要不打扰基本的数据传输，就可以添加任意额外的东⻄。</p>
<h2 id="HTTP-是⽤于从互联⽹服务器传输超⽂本到本地浏览器的协议-，这种说法正确吗？"><a href="#HTTP-是⽤于从互联⽹服务器传输超⽂本到本地浏览器的协议-，这种说法正确吗？" class="headerlink" title="HTTP 是⽤于从互联⽹服务器传输超⽂本到本地浏览器的协议 ，这种说法正确吗？"></a>HTTP 是⽤于从互联⽹服务器传输超⽂本到本地浏览器的协议 ，这种说法正确吗？</h2><p>不正确的。因为也可以是「服务器&lt; –&gt;服务器」，所以采⽤两点之间的描述会更准确</p>
<h2 id="HTTP-常⻅的状态码"><a href="#HTTP-常⻅的状态码" class="headerlink" title="HTTP 常⻅的状态码"></a>HTTP 常⻅的状态码</h2><img src="/2024/04/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/clip_image002.gif" class="">

<ul>
<li><p><em>1xx</em></p>
<p>​    属于提示信息，是协议处理中的⼀种中间状态，实际⽤到的⽐较少。</p>
</li>
<li><p><em>2xx</em></p>
<p>​    表示服务器成功处理了客户端的请求</p>
<p>​    「<strong>200 OK</strong>」是最常⻅的成功状态码，表示⼀切正常。如果是⾮ HEAD 请求，服务器返回的响应头都会有 body 数据。（HEAD：HEAD和GET本质是一样的，区别在于HEAD不含有呈现数据，而仅仅是HTTP头信息。有的人可能觉得这个方法没什么用，其实不是这样的。想象一个业务情景：欲判断某个资源是否存在，我们通常使用GET，但这里用HEAD则意义更加明确。）</p>
<p>​    「<strong>204 No Content</strong>」也是常⻅的成功状态码，与 200 OK 基本相同，但响应头没有 body 数据。</p>
<p>​    「<strong>206 Partial Content</strong>」是应⽤于 HTTP 分块下载或断点续传，表示响应返回的body 数据并不是资源的全部，⽽是其中的⼀部分，也是服务器处理成功的状态。</p>
</li>
<li><p><em>3xx</em></p>
<p>​    表示客户端请求的资源发送了变动，需要客户端⽤新的 URL 重新发送请求获取资源，也就是重定向。</p>
<p>​    「<strong>301 Moved Permanently</strong>」表示永久重定向，说明请求的资源已经不存在了，需改⽤新的 URL 再次访问。</p>
<p>​    「<strong>302 Found</strong>」表示临时重定向，说明请求的资源还在，但暂时需要⽤另⼀个 URL 来访问。301 和 302 都会在响应头⾥使⽤字段 Location ，指明后续要跳转的 URL，浏览器会⾃动重定向新的 URL。</p>
</li>
</ul>
<p>​    「<strong>304 Not Modified</strong>」不具有跳转的含义，表示资源未修改，重定向已存在的缓冲⽂件，也称缓存重定向，⽤于缓存控制。</p>
<ul>
<li><p><em>4xx</em></p>
<p>​    表示客户端发送的报⽂有误，服务器⽆法处理，也就是错误码的含义。</p>
<p>​    「<strong>400 Bad Request</strong>」表示客户端请求的报⽂有错误，但只是个笼统的错误。</p>
<p>​    「<strong>403 Forbidden</strong>」表示服务器禁⽌访问资源，并不是客户端的请求出错。</p>
<p>​    「<strong>404 Not Found</strong>」表示请求的资源在服务器上不存在或未找到，所以⽆法提供给客户端。</p>
</li>
<li><p><em>5xx</em></p>
<p>​    表示客户端请求报⽂正确，但是服务器处理时内部发⽣了错误，属于服务器端的错误码。</p>
<p>  「<strong>500 Internal Server Error</strong>」与 400 类型，是个笼统通⽤的错误码，服务器发⽣了什么错误，我们并不知道。</p>
<p>「<strong>501 Not Implemented</strong>」表示客户端请求的功能还不⽀持，类似“即将开业，敬请期待”的意思。</p>
<p>「<strong>502 Bad Gateway</strong>」通常是服务器作为⽹关或代理时返回的错误码，表示服务器⾃身⼯作正常，访问后端服务器发⽣了错误。</p>
<p>「<strong>503 Service Unavailable</strong>」表示服务器当前很忙，暂时⽆法响应服务器，类似“⽹络服务正忙，请稍后重试”的意思。</p>
</li>
</ul>
<h2 id="http-常⻅字段有哪些"><a href="#http-常⻅字段有哪些" class="headerlink" title="http 常⻅字段有哪些"></a>http 常⻅字段有哪些</h2><ol>
<li><em>Host</em> 字段：客户端发送请求时，⽤来指定服务器的域名。</li>
</ol>
<p>​          Host: <a target="_blank" rel="noopener" href="http://www.a.com/">www.A.com</a>    可以将请求发往「同⼀台」服务器上的不同⽹站。</p>
<ol start="2">
<li><em>Content</em>-<em>Length</em> 字段：服务器在返回数据时，会有 Content-Length 字段，表明本次回应的数据⻓度。</li>
</ol>
<p>​      Content-Length: 1000    是告诉浏览器，本次服务器回应的数据⻓度是 1000 个字节，后⾯的字节就属于下⼀个回应了。</p>
<ol start="3">
<li><em>Connection</em> 字段：常⽤于客户端要求服务器使⽤ TCP 持久连接，以便其他请求复⽤。</li>
</ol>
<p>​       Connection: keep-alive    持久连接，但为了兼容⽼版本的 HTTP，需要指定 Connection ⾸部字段的值为Keep-Alive 。</p>
<ol start="4">
<li><em>Content</em>-<em>Type</em> 字段：于服务器回应时，告诉客户端，本次数据是什么格式。</li>
</ol>
<p>​       Content-Type: text&#x2F;html; charset&#x3D;utf-8上⾯的类型表明，发送的是⽹⻚，⽽且编码是UTF-8。</p>
<p>​       客户端请求的时候，可以使⽤ Accept 字段声明⾃⼰可以接受哪些数据格式。</p>
<p>​       Accept: **&#x2F;**上⾯代码中，客户端声明⾃⼰可以接受任何格式的数据。</p>
<ol start="5">
<li><em>Content</em>-<em>Encoding</em> 字段：说明数据的压缩⽅法。表示服务器返回的数据使⽤了什么压缩格式</li>
</ol>
<p>​        Content-Encoding: gzip    服务器返回的数据采⽤了 gzip ⽅式压缩，告知客户端需要⽤此⽅式解压。</p>
<p>​        Accept-Encoding: gzip, deflate：说明⾃⼰可以接受哪些压缩⽅法。</p>
<p>​	6. User Agent也简称UA。 它是一个特殊字符串头，是一种向访问网站提供你所使用的浏览器类型及版本、操作系统及版本、浏览器内核、等信息的标识。</p>
<h2 id="说⼀下-GET-和-POST-的区别"><a href="#说⼀下-GET-和-POST-的区别" class="headerlink" title="说⼀下 GET 和 POST 的区别"></a>说⼀下 GET 和 POST 的区别</h2><p>Get ⽅法的含义是请求从服务器获取资源，这个资源可以是静态的⽂本、⻚⾯、图⽚视频等。</p>
<p>POST ⽅法则是相反操作，它向 URI 指定的资源提交数据，数据就放在报⽂的 body ⾥。</p>
<p>功能区别：get获取数据，post提交数据</p>
<p>url：get携带数据，post不携带，在请求体中</p>
<p>url长度限制</p>
<p>get数据包一个，post两个</p>
<img src="/2024/04/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/clip_image003.jpg" class="" width="0">

<h2 id="GET-和-POST-⽅法都是安全和幂等的吗"><a href="#GET-和-POST-⽅法都是安全和幂等的吗" class="headerlink" title="GET 和 POST ⽅法都是安全和幂等的吗"></a>GET 和 POST ⽅法都是安全和幂等的吗</h2><ul>
<li><p>「安全」是指请求⽅法不会「破坏」服务器上的资源。</p>
</li>
<li><p>「幂等」，意思是多次执⾏相同的操作，结果都是「相同」的。</p>
<p>​	<strong>GET</strong> ⽅法就是安全且幂等的，因为它是「只读」操作，⽆论操作多少次，服务器上的数据都是安全的，且每次的结果都是相同的。</p>
<p>​	<strong>POST</strong> 因为是「新增或提交数据」的操作，会修改服务器上的资源，所以是不安全的，且多次提交数据就会创建多个资源，所以不是幂等的。</p>
</li>
</ul>
<h2 id="HTTP-的优点有哪些"><a href="#HTTP-的优点有哪些" class="headerlink" title="HTTP 的优点有哪些"></a>HTTP 的优点有哪些</h2><p>HTTP 最凸出的优点是「简单、灵活和易于扩展、应⽤⼴泛和跨平台」。</p>
<ol>
<li><p>简单：HTTP 基本的报⽂格式就是 header + body ，头部信息也是 key-value 简单⽂本的形式。</p>
</li>
<li><p>灵活和易于扩展：HTTP协议⾥的各类请求⽅法、URI&#x2F;URL、状态码、头字段等每个组成要求都没有被固定死，都允许开发⼈员⾃定义和扩充。同时 HTTP 由于是⼯作在应⽤层（ OSI 第七层），则它下层可以随意变化。HTTPS 也就是在 HTTP 与 TCP 层之间增加了 SSL&#x2F;TLS 安全传输层，HTTP&#x2F;3 甚⾄把 TCP 层换成了基于 UDP 的QUIC。</p>
</li>
<li><p>应⽤⼴泛和跨平台：从台式机的浏览器到⼿机上的各种 APP，同时天然具有跨平台的优越性。</p>
</li>
</ol>
<h2 id="HTTP-的缺点有哪些"><a href="#HTTP-的缺点有哪些" class="headerlink" title="HTTP 的缺点有哪些"></a><strong>HTTP</strong> <strong>的缺点有哪些</strong></h2><p>「⽆状态、明⽂传输」「不安全」</p>
<p>​    <em>1.</em> ⽆状态双刃剑</p>
<p>​    ⽆状态的好处，因为服务器不会去记忆 HTTP 的状态，所以不需要额外的资源来记录状态信息，这能减轻服务器的负担，能够把更多的 CPU 和内存⽤来对外提供服务。</p>
<p>​    ⽆状态的坏处，既然服务器没有记忆能⼒，它在完成有关联性的操作时会⾮常麻烦。例如登录-添加购物⻋-下单-结算-⽀付，这系列操作都要知道⽤户的身份才⾏。但服务器不知道这些请求是有关联的，每次都要问⼀遍身份信息。</p>
<p>​    解法⽅案：Cookie 通过在请求和响应报⽂中写⼊ Cookie 信息来控制客户端的状态。</p>
<p>​    2. 明⽂传输双刃剑</p>
<p>​    ⽅便阅读的，通过浏览器的 F12 控制台或 Wireshark 抓包都可以直接⾁眼查看，为调试⼯作带了极⼤的便利性。</p>
<p>​    信息的内容都毫⽆隐私可⾔，很容易就能被窃取，如果⾥⾯有你的账号密码信息，那你号没了。</p>
<p>​    3.不安全</p>
<p>​    通信使⽤明⽂（不加密），内容可能会被窃听。⽐如，账号信息容易泄漏，那你号没了。</p>
<p>​    不验证通信⽅的身份，因此有可能遭遇伪装。⽐如，访问假的淘宝、拼多多，那你钱没了。</p>
<p>​    ⽆法证明报⽂的完整性，所以有可能已遭篡改。⽐如，⽹⻚上植⼊垃圾⼴告，视觉污染，眼没了。</p>
<p>​    HTTP 的安全问题，可以⽤ HTTPS 的⽅式解决，通过引⼊ SSL&#x2F;TLS 层。</p>
<h2 id="HTTP-1-1-的性能如何？"><a href="#HTTP-1-1-的性能如何？" class="headerlink" title="HTTP&#x2F;1.1 的性能如何？"></a>HTTP&#x2F;1.1 的性能如何？</h2><p>HTTP 协议是基于 <strong>TCP&#x2F;IP</strong>，并且使⽤了「请求 -应答」的通信模式，所以性能的关键就在这两点⾥。</p>
<p>​    <em>1.</em> ⻓连接</p>
<p>​    早期 HTTP&#x2F;1.0 性能上的⼀个很⼤的问题，那就是每发起⼀个请求，都要新建⼀次 TCP 连接（三次握⼿），⽽且是串⾏请求，做了⽆谓的 TCP 连接建⽴和断开，增加了通信开销。</p>
<p>​    HTTP&#x2F;1.1 提出了⻓连接的通信⽅式，持久连接的特点是，只要任意⼀端没有明确提出断开连接，则保持 TCP 连接状态。</p>
<p>​    <em>2.</em> 管道⽹络传输</p>
<p>​    即可在同⼀个 TCP 连接⾥⾯，客户端可以发起多个请求，只要第⼀个请求发出去了，不必等其回来，就可以发第⼆个请求出去，可以减少整体的响应时间。举例来说，客户端需要请求两个资源。以前的做法是，在同⼀个TCP连接⾥⾯，先发送 A 请求，然后等待服务器做出回应，收到后再发出 B 请求。管道机制则是允许浏览器同时发出 A 请求和 B 请求。</p>
<p>​    3.队头阻塞        </p>
<p>​    但是服务器还是按照顺序，先回应 A 请求，完成后再回应 B 请求。要是前⾯的回应特别慢，后⾯就会有许多请求排队等着。这称为「队头堵塞」。</p>
<h1 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a><strong>HTTPS</strong></h1><h2 id="HTTP-与-HTTPS-有哪些区别？"><a href="#HTTP-与-HTTPS-有哪些区别？" class="headerlink" title="HTTP 与 HTTPS 有哪些区别？"></a>HTTP 与 HTTPS 有哪些区别？</h2><ol>
<li><p>HTTP 是超⽂本传输协议，信息是明⽂传输，存在安全⻛险的问题。HTTPS 则解决 HTTP 不安全的缺陷，在 TCP 和 HTTP ⽹络层之间加⼊了 SSL&#x2F;TLS 安全协议，使得报⽂能够加密传输。</p>
</li>
<li><p>HTTP 连接建⽴相对简单， TCP 三次握⼿之后便可进⾏ HTTP 的报⽂传输。⽽ HTTPS 在 TCP 三次握⼿之 后，还需进⾏ SSL&#x2F;TLS 的握⼿过程，才可进⼊加密报⽂传输。 </p>
</li>
<li><p>HTTP 的端⼝号是 80，HTTPS 的端⼝号是 443。 </p>
</li>
<li><p>HTTPS 协议需要向 CA（证书权威机构）申请数字证书，来保证服务器的身份是可信的。</p>
</li>
</ol>
<h2 id="HTTP和HTTPS请求的整个过程详解"><a href="#HTTP和HTTPS请求的整个过程详解" class="headerlink" title="HTTP和HTTPS请求的整个过程详解"></a>HTTP和HTTPS请求的整个过程详解</h2><img src="/2024/04/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/clip_image005.jpg" class="">

<p>HTTP请求的过程：</p>
<ol>
<li><p>浏览器根据域名解析IP地址</p>
</li>
<li><p>浏览器与WEB服务器建立一个TCP连接</p>
</li>
</ol>
<p>TCP的3次握手过程。</p>
<ol start="3">
<li><p>浏览器给WEB服务器发送一个HTTP请求</p>
</li>
<li><p>服务器端响应HTTP请求，浏览器得到HTML代码</p>
</li>
<li><p>浏览器解析HTML代码，并请求HTML代码中的资源</p>
</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://blog.fundebug.com/2019/02/28/what-happens-from-url-to-webpage/">https://blog.fundebug.com/2019/02/28/what-happens-from-url-to-webpage/</a></p>
<p><strong>HTTPS请求的过程</strong></p>
<ul>
<li><ul>
<li>1.客户端向服务器发起HTTPS的请求，连接到服务器的443端口；</li>
<li>2.服务器将非对称加密的公钥传递给客户端，以证书的形式回传到客户端；</li>
<li>3.客户端接受到该公钥进行验证，如果有问题，则HTTPS请求无法继续；如果没有问题，客户端这个时  候随机生成一个私钥，称为client key,用于对称加密数据的。使用前面的公钥对client      key进行非对称加密；客户端发起二次HTTP请求，将加密之后的client key传递给服务器；</li>
<li>4.服务器使用私钥进行解密，得到client key,使用client key对数据进行对称加密；</li>
<li>5.将对称加密的数据传递给客户端，客户端使用对称解密，得到服务器发送的数据，完成第二次HTTP请求。</li>
</ul>
</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/GavinBC/article/details/107001255">https://blog.csdn.net/GavinBC/article/details/107001255</a></p>
<h2 id="HTTPS-解决了-HTTP-的哪些问题？"><a href="#HTTPS-解决了-HTTP-的哪些问题？" class="headerlink" title="HTTPS 解决了 HTTP 的哪些问题？"></a>HTTPS 解决了 HTTP 的哪些问题？</h2><p>HTTP 由于是明⽂传输，所以安全上存在以下三个⻛险： </p>
<ul>
<li><p>窃听⻛险，⽐如通信链路上可以获取通信内容，⽤户号容易没。 </p>
</li>
<li><p>篡改⻛险，⽐如强制植⼊垃圾⼴告，视觉污染，⽤户眼容易瞎。 </p>
</li>
<li><p>冒充⻛险，⽐如冒充淘宝⽹站，⽤钱容易没。</p>
</li>
</ul>
<p>HTTP<strong>S</strong> 在 HTTP 与 TCP 层之间加⼊了 SSL&#x2F;TLS 协议，可以很好的解决了上述的⻛险： </p>
<ul>
<li><p>信息加密：交互信息⽆法被窃取，但你的号会因为「⾃身忘记」账号⽽没。 </p>
</li>
<li><p>校验机制：⽆法篡改通信内容，篡改了就不能正常显示，但百度「竞价排名」依然可以搜索垃圾⼴告。 </p>
</li>
<li><p>身份证书：证明淘宝是真的淘宝⽹，但你的钱还是会因为「剁⼿」没。</p>
</li>
</ul>
<p>HTTPS 是如何解决上⾯的三个⻛险的？ </p>
<p>混合加密的⽅式实现信息的机密性，解决了窃听的⻛险。</p>
<p>摘要算法的⽅式来实现完整性，它能够为数据⽣成独⼀⽆⼆的「指纹」，指纹⽤于校验数据的完整性，解决了 篡改的⻛险。</p>
<p>将服务器公钥放⼊到数字证书中，解决了冒的⻛险。</p>
<ol>
<li><p>混合加密</p>
<p>在通信建⽴前采⽤⾮对称加密的⽅式交换「会话秘钥」，后续就不再使⽤⾮对称加密。</p>
<p>在通信过程中全部使⽤对称加密的「会话秘钥」的⽅式加密明⽂数据。</p>
<p>采⽤「混合加密」的⽅式的原因： </p>
<p>对称加密只使⽤⼀个密钥，运算速度快，密钥必须保密，⽆法做到安全的密钥交换。 </p>
<p>⾮对称加密使⽤两个密钥：公钥和私钥，公钥可以任意分发⽽私钥保密，解决了密钥交换问题但速度。</p>
</li>
<li><p>摘要算法 </p>
<p>摘要算法⽤来实现完整性，能够为数据⽣成独⼀⽆⼆的「指纹」，⽤于校验数据的完整性，解决了篡改的⻛险</p>
<p>客户端在发送明⽂之前会通过摘要算法算出明⽂的「指纹」，发送的时候把「指纹 + 明⽂」⼀同加密成密⽂后，发送给服务器，服务器解密后，⽤相同的摘要算法算出发送过来的明⽂，通过⽐较客户端携带的「指纹」和当前算出的「指纹」做⽐较，若「指纹」相同，说明数据是完整的。</p>
</li>
<li><p>数字证书 </p>
<p>客户端先向服务器端索要公钥，然后⽤公钥加密信息，服务器收到密⽂后，⽤⾃⼰的私钥解密。 </p>
<p>这就存在些问题，如何保证公钥不被篡改和信任度？ </p>
<p>所以这⾥就需要借助第三⽅权威机构 CA （数字证书认证机构），将服务器公钥放在数字证书（由数字证书认证机构颁发）中，只要证书是可信的，公钥就是可信的。</p>
</li>
</ol>
<h2 id="HTTPS-是如何建⽴连接的？"><a href="#HTTPS-是如何建⽴连接的？" class="headerlink" title="HTTPS 是如何建⽴连接的？"></a>HTTPS 是如何建⽴连接的？</h2><p>SSL&#x2F;TLS 协议基本流程： </p>
<ul>
<li><p>客户端向服务器索要并验证服务器的公钥。 </p>
</li>
<li><p>双⽅协商⽣产「会话秘钥」。</p>
</li>
<li><p>双⽅采⽤「会话秘钥」进⾏加密通信。</p>
</li>
</ul>
<p>SSL&#x2F;TLS 协议建⽴的详细流程： </p>
<p><em>1. ClientHello</em> </p>
<p>⾸先，由客户端向服务器发起加密通信请求，也就是 ClientHello 请求。 在这⼀步，客户端主要向服务器发送以下信息：</p>
<p>（1）客户端⽀持的 SSL&#x2F;TLS 协议版本，如 TLS 1.2 版本。 </p>
<p>（2）客户端⽣产的随机数（ Client Random ），后⾯⽤于⽣产「会话秘钥」。 </p>
<p>（3）客户端⽀持的密码套件列表，如 RSA 加密算法。 </p>
<p><em>2. SeverHello</em> </p>
<p>服务器收到客户端请求后，向客户端发出响应，也就是 SeverHello 。服务器回应的内容有如下内容： </p>
<p>（1）确认 SSL&#x2F; TLS 协议版本，如果浏览器不⽀持，则关闭加密通信。 </p>
<p>（2）服务器⽣产的随机数（ Server Random ），后⾯⽤于⽣产「会话秘钥」。 </p>
<p>（3）确认的密码套件列表，如 RSA 加密算法。 </p>
<p>（4）服务器的数字证书。 </p>
<p><em>3.</em> 客户端回应 </p>
<p>客户端收到服务器的回应之后，⾸先通过浏览器或者操作系统中的 CA 公钥，确认服务器的数字证书的真实性。</p>
<p>如果证书没有问题，客户端会从数字证书中取出服务器的公钥，然后使⽤它加密报⽂，向服务器发送如下信息： </p>
<p>（1）⼀个随机数（ pre-master key ）。该随机数会被服务器公钥加密。 </p>
<p>（2）加密通信算法改变通知，表示随后的信息都将⽤「会话秘钥」加密通信。 </p>
<p>（3）客户端握⼿结束通知，表示客户端的握⼿阶段已经结束。这⼀项同时把之前所有内容的发⽣的数据做个摘 要，⽤来供服务端校验。上⾯第⼀项的随机数是整个握⼿阶段的第三个随机数，这样服务器和客户端就同时有三个随机数，接着就⽤双⽅协 商的加密算法，各⾃⽣成本次通信的「会话秘钥」。</p>
<p><em>4.</em> 服务器的最后回应 </p>
<p>服务器收到客户端的第三个随机数（ pre-master key ）之后，通过协商的加密算法，计算出本次通信的「会话秘 钥」。然后，向客户端发⽣最后的信息： </p>
<p>（1）加密通信算法改变通知，表示随后的信息都将⽤「会话秘钥」加密通信。 </p>
<p>（2）服务器握⼿结束通知，表示服务器的握⼿阶段已经结束。这⼀项同时把之前所有内容的发⽣的数据做个摘 要，⽤来供客户端校验。 </p>
<p>⾄此，整个 SSL&#x2F;TLS 的握⼿阶段全部结束。接下来，客户端与服务器进⼊加密通信，就完全是使⽤普通的 HTTP </p>
<h1 id="HTTP-1-1、HTTP-2、HTTP-3-演变"><a href="#HTTP-1-1、HTTP-2、HTTP-3-演变" class="headerlink" title="HTTP&#x2F;1.1、HTTP&#x2F;2、HTTP&#x2F;3 演变"></a><strong>HTTP&#x2F;1.1</strong>、<strong>HTTP&#x2F;2</strong>、<strong>HTTP&#x2F;3</strong> 演变</h1><h2 id="HTTP-1-1-相⽐-HTTP-1-0-提⾼了什么性能？"><a href="#HTTP-1-1-相⽐-HTTP-1-0-提⾼了什么性能？" class="headerlink" title="HTTP&#x2F;1.1 相⽐ HTTP&#x2F;1.0 提⾼了什么性能？"></a>HTTP&#x2F;1.1 相⽐ HTTP&#x2F;1.0 提⾼了什么性能？</h2><p>HTTP&#x2F;1.1 相⽐ HTTP&#x2F;1.0 性能上的改进： </p>
<ul>
<li><p>​	使⽤ TCP ⻓连接的⽅式改善了 HTTP&#x2F;1.0 短连接造成的性能开销。 </p>
</li>
<li><p>​	⽀持管道（pipeline）⽹络传输，只要第⼀个请求发出去了，不必等其回来，就可以发第⼆个请求出去，可以 减少整体的响应时间。</p>
</li>
</ul>
<p>但 HTTP&#x2F;1.1 还是有性能瓶颈： </p>
<ul>
<li><p>​	请求 &#x2F; 响应头部（Header）未经压缩就发送，⾸部信息越多延迟越⼤。只能压缩 Body 的部分； </p>
</li>
<li><p>​	发送冗⻓的⾸部。每次互相发送相同的⾸部造成的浪费较多； </p>
</li>
<li><p>​	服务器是按请求的顺序响应的，如果服务器响应慢，会招致客户端⼀直请求不到数据，也就是队头阻塞； </p>
</li>
<li><p>​	没有请求优先级控制；</p>
</li>
<li><p>​	请求只能从客户端开始，服务器只被动响应。</p>
</li>
</ul>
<h2 id="HTTP-2"><a href="#HTTP-2" class="headerlink" title="HTTP&#x2F;2"></a>HTTP&#x2F;2</h2><p><em>1.</em> 头部压缩HTTP&#x2F;2 会压缩头（Header）</p>
<p>如果你同时发出多个请求，他们的头是⼀样的或是相似的，那么，协议会帮你消除重 复的部分。 这就是所谓的 HPACK 算法：在客户端和服务器同时维护⼀张头信息表，所有字段都会存⼊这个表，⽣成⼀个索引号，以后就不发送同样字段了，只发送索引号，这样就提⾼速度了。 </p>
<p><em>2.</em> ⼆进制格式 </p>
<p>HTTP&#x2F;2 不再像 HTTP&#x2F;1.1 ⾥的纯⽂本形式的报⽂，⽽是全⾯采⽤了⼆进制格式，头信息和数据体都是⼆进制，并 且统称为帧（frame）：头信息帧和数据帧。但是对计算机⾮常友好，因为计算机只懂⼆进制，那么收到报⽂后，⽆需再将明⽂的报⽂转成⼆进制，⽽是直接解析⼆进制报⽂，这增加了数据传输效率。</p>
<p><em>3.</em> 数据流 </p>
<p>HTTP&#x2F;2 的数据包不是按顺序发送的，同⼀个连接⾥⾯连续的数据包，可能属于不同的回应。因此，必须要对数据 包做标记，指出它属于哪个回应。</p>
<p>每个请求或回应的所有数据包，称为⼀个数据流（ Stream ）。每个数据流都标记着⼀个独⼀⽆⼆的编号，其中规 定客户端发出的数据流编号为奇数， 服务器发出的数据流编号为偶数，</p>
<p>客户端还可以指定数据流的优先级。优先级⾼的请求，服务器就先响应该请求。</p>
<p><em>4.</em> 多路复⽤ </p>
<p>HTTP&#x2F;2 是可以在⼀个连接中并发多个请求或回应，⽽不⽤按照顺序⼀⼀对应。 </p>
<p>移除了 HTTP&#x2F;1.1 中的串⾏请求，不需要排队等待，也就不会再出现「队头阻塞」问题，降低了延迟，⼤幅度提⾼ 了连接的利⽤率。 </p>
<p>举例来说，在⼀个 TCP 连接⾥，服务器收到了客户端 A 和 B 的两个请求，如果发现 A 处理过程⾮常耗时，于是就 回应 A 请求已经处理好的部分，接着回应 B 请求，完成后，再回应 A 请求剩的部分。</p>
<p><em>5.</em> 服务器推送 </p>
<p>HTTP&#x2F;2 还在⼀定程度上改善了传统的「请求 - 应答」⼯作模式，服务不再是被动地响应，也可以主动向客户端发 送消息。 </p>
<p>举例来说，在浏览器刚请求 HTML 的时候，就提前把可能会⽤到的 JS、CSS ⽂件等静态资源主动发给客户端，减 少延时的等待，也就是服务器推送（Server Push，也叫 Cache Push）。 </p>
<h2 id="HTTP-3"><a href="#HTTP-3" class="headerlink" title="HTTP&#x2F;3"></a>HTTP&#x2F;3</h2><p>HTTP&#x2F;2 主要的问题在于，多个 HTTP 请求在复⽤⼀个 TCP 连接，下层的 TCP 协议是不知道有多少个 HTTP 请求 的。所以⼀旦发⽣了丢包现象，就会触发 TCP 的᯿传机制，这样在⼀个 TCP 连接中的所有的 <strong>HTTP</strong> 请求都必须等 待这个丢了的包被重传回来。 </p>
<p>HTTP&#x2F;1.1 中的管道（ pipeline）传输中如果有⼀个请求阻塞了，那么队列后请求也统统被阻塞住了 HTTP&#x2F;2 多个请求复⽤⼀个TCP连接，⼀旦发⽣丢包，就会阻塞住所有的 HTTP 请求。 </p>
<p>这都是基于 TCP 传输层的问题，所以 <strong>HTTP&#x2F;3</strong> 把 <strong>HTTP</strong> 下层的 <strong>TCP</strong> 协议改成了 <strong>UDP</strong>！</p>
<p>UDP 发⽣是不管顺序，也不管丢包的，所以不会出现 HTTP&#x2F;1.1 的队头阻塞 和 HTTP&#x2F;2 的</p>
<p>⼀个丢包全部重传问题。</p>
<p> UDP 是不可靠传输的，但基于 UDP 的 <strong>QUIC</strong> 协议 可以实现类似 TCP 的可靠性传输。 </p>
<p>QUIC 有⾃⼰的⼀套机制可以保证传输的可靠性的。当某个流发⽣丢包时，只会阻塞这个流，其他流不会受到 影响。 </p>
<p>TLS3 升级成了最新的 1.3 版本，头部压缩算法也升级成了 QPack 。 </p>
<p>HTTPS 要建⽴⼀个连接，要花费 6 次交互，先是建⽴三次握⼿，然后是 TLS&#x2F;1.3 的三次握⼿。QUIC 直接把 以往的 TCP 和 TLS&#x2F;1.3 的 6 次交互合并成了 <strong>3</strong> 次，减少了交互次数。</p>
<p>QUIC 是⼀个在 UDP 之上的伪 TCP + TLS + HTTP&#x2F;2 的多路复⽤的协议。 </p>
<p>QUIC 是新协议，对于很多⽹络设备，根本不知道什么是 QUIC，只会当做 UDP，这样会出现新的问题。所以HTTP&#x2F;3 现在普及的进度⾮常的缓慢，不知道未来 UDP 是否能够逆袭 TCP。</p>
<img src="/2024/04/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/clip_image006.jpg" class="" width="0">

<img src="/2024/04/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/clip_image007.jpg" class="" width="0">

<img src="/2024/04/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/clip_image008.jpg" class="" width="0">

<h1 id="TCP与UDP"><a href="#TCP与UDP" class="headerlink" title="TCP与UDP"></a>TCP与UDP</h1><h2 id="基本认识"><a href="#基本认识" class="headerlink" title="基本认识"></a>基本认识</h2><h3 id="TCP-头格式"><a href="#TCP-头格式" class="headerlink" title="TCP 头格式"></a>TCP 头格式</h3><ul>
<li><ol>
<li>序列号：在建⽴连接时由计算机⽣成的随机数作为其初始值，通过      SYN 包传给接收端主机，每发送⼀次数据，就「累加」⼀次该「数据字节数」的⼤⼩。⽤来解决⽹络包乱序问题。</li>
<li>确认应答号：指下⼀次「期望」收到的数据的序列号，发送端收到这个确认应答以后可以认为在这个序号以前的数据都已经被正常接收。⽤来解决不丢包的问题。</li>
<li>控制位：</li>
</ol>
</li>
<li><ul>
<li><em>ACK</em>：该位为1 时，「确认应答」的字段变为有效，TCP 规定除了最初建⽴连接时的 SYN 包之外该位必须设置为 1 。</li>
<li><em>RST</em>：该位为1 时，表示 TCP 连接中出现异常必须强制断开连接。</li>
<li><em>SYN</em>：该位为1 时，表示希望建⽴连接，并在其「序列号」的字段进⾏序列号初始值的设定。</li>
<li><em>FIN</em>：该位为1 时，表示今后不会再有数据发送，希望断开连接。当通信结束希望断开连接时，通信双⽅的主机之间就可以相互交换 FIN 位为 1 的 TCP 段。</li>
</ul>
</li>
</ul>
<h3 id="为什么需要-TCP-协议？-TCP-⼯作在哪⼀层？"><a href="#为什么需要-TCP-协议？-TCP-⼯作在哪⼀层？" class="headerlink" title="为什么需要 TCP 协议？ TCP ⼯作在哪⼀层？"></a><strong>为什么需要</strong> <strong>TCP</strong> <strong>协议？</strong> <strong>TCP</strong> <strong>⼯作在哪⼀层？</strong></h3><p>IP 层是「不可靠」的，它不保证⽹络包的交付、不保证⽹络包的按序交付、也不保证⽹络包中的数据的完整性。</p>
<p>如果需要保障⽹络数据包的可靠性，那么就需要由上层（传输层）的 TCP 协议来负责。</p>
<p>因为 TCP 是⼀个⼯作在<strong>传输层</strong>的可靠数据传输的服务，它能确保接收端接收的⽹络包是⽆损坏、⽆间隔、⾮冗余和按序的。</p>
<h3 id="什么是-TCP-？"><a href="#什么是-TCP-？" class="headerlink" title="什么是 TCP ？"></a><strong>什么是</strong> <strong>TCP</strong> <strong>？</strong></h3><p>TCP 是⾯向连接的、可靠的、基于字节流的传输层通信协议。</p>
<ul>
<li><p>⾯向连接：⼀定是「⼀对⼀」才能连接，不能像 UDP 协议可以⼀个主机同时向多个主机发送消息，也就是⼀对多是⽆法做到的；</p>
</li>
<li><p>可靠的：⽆论的⽹络链路中出现了怎样的链路变化，TCP 都可以保证⼀个报⽂⼀定能够到达接收端；</p>
</li>
<li><p>字节流：消息是「没有边界」的，所以⽆论我们消息有多⼤都可以进⾏传输。并且消息是「有序的」，当「前⼀个」消息没有收到的时候，即使它先收到了后⾯的字节，那么也不能扔给应⽤层去处理，同时对「重复」的报⽂会⾃动丢弃。</p>
</li>
</ul>
<h3 id="什么是-TCP-连接？"><a href="#什么是-TCP-连接？" class="headerlink" title="什么是 TCP 连接？"></a><strong>什么是</strong> <strong>TCP</strong> <strong>连接？</strong></h3><p>⽤于保证可靠性和流量控制维护的某些状态信息，这些信息的组合，包括<strong>Socket</strong>、序列号和窗⼝⼤⼩称为连接。</p>
<p>建⽴⼀个 TCP 连接是需要客户端与服务器端达成上述三个信息的共识。</p>
<ul>
<li><p>- Socket：由 IP 地址和端⼝号组成</p>
</li>
<li><p>- 序列号：⽤来解决乱序问题等</p>
</li>
<li><p>- 窗⼝⼤⼩：⽤来做流量控制</p>
</li>
</ul>
<h3 id="如何唯⼀确定⼀个-TCP-连接呢？"><a href="#如何唯⼀确定⼀个-TCP-连接呢？" class="headerlink" title="如何唯⼀确定⼀个 TCP 连接呢？"></a>如何唯⼀确定⼀个 TCP 连接呢？</h3><p>TCP 四元组可以唯⼀的确定⼀个连接，四元组包括如下：</p>
<ul>
<li><p>- 源地址</p>
</li>
<li><p>- 源端⼝</p>
</li>
<li><p>- ⽬的地址</p>
</li>
<li><p>- ⽬的端⼝</p>
</li>
</ul>
<p> 源地址和⽬的地址的字段（32位）是在 IP 头部中，作⽤是通过 IP 协议发送报⽂给对⽅主机。</p>
<p> 源端⼝和⽬的端⼝的字段（16位）是在 TCP 头部中，作⽤是告诉 TCP 协议应该把报⽂发给哪个进程。</p>
<h3 id="有⼀个-IP-的服务器监听了⼀个端⼝，它的-TCP-的最⼤连接数是多少？"><a href="#有⼀个-IP-的服务器监听了⼀个端⼝，它的-TCP-的最⼤连接数是多少？" class="headerlink" title="有⼀个 IP 的服务器监听了⼀个端⼝，它的 TCP 的最⼤连接数是多少？"></a>有⼀个 IP 的服务器监听了⼀个端⼝，它的 TCP 的最⼤连接数是多少？</h3><p>服务器通常固定在某个本地端⼝上监听，等待客户端的连接请求。</p>
<p>因此，客户端 IP 和 端⼝是可变的，其理论值计算公式如下: </p>
<img src="/2024/04/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/clip_image010.gif" class="">

<p>对 IPv4，客户端的 IP 数最多为 2 的 32 次⽅，客户端的端⼝数最多为 2 的 16 次⽅，也就是服务端单机最⼤TCP 连接数，约为 2 的 48 次⽅。</p>
<p>当然，服务端最⼤并发 TCP 连接数远不能达到理论上限。</p>
<ul>
<li><p>- ⾸先主要是⽂件描述符限制，Socket 都是⽂件，所以⾸先要通过 ulimit 配置⽂件描述符的数⽬；</p>
</li>
<li><p>- 另⼀个是内存限制，每个 TCP 连接都要占⽤⼀定内存，操作系统的内存是有限的。</p>
</li>
</ul>
<h3 id="UDP-和-TCP-有什么区别呢？"><a href="#UDP-和-TCP-有什么区别呢？" class="headerlink" title="UDP 和 TCP 有什么区别呢？"></a><strong>UDP</strong> <strong>和</strong> <strong>TCP</strong> <strong>有什么区别呢？</strong></h3><p><strong>UDP概念</strong></p>
<p>UDP 不提供复杂的控制机制，利⽤ IP 提供⾯向「⽆连接」的通信服务。</p>
<p>UDP 协议真的⾮常简单，头部只有 8 个字节（ 64 位），UDP 的头部格式如下：</p>
<ul>
<li><p>- ⽬标和源端⼝：主要是告诉 UDP 协议应该把报⽂发给哪个进程。</p>
</li>
<li><p>- 包⻓度：该字段保存了 UDP ⾸部的⻓度跟数据的⻓度之和。</p>
</li>
<li><p>- 校验和：校验和是为了提供可靠的 UDP ⾸部和数据⽽设计。</p>
</li>
</ul>
<p><strong>TCP和 UDP 区别：</strong></p>
<p><em>1.</em> 连接</p>
<p>​	TCP 是⾯向连接的传输层协议，传输数据前先要建⽴连接。</p>
<p>​	UDP 是不需要连接，即刻传输数据。</p>
<p><em>2.</em> 服务对象</p>
<p>​	TCP 是⼀对⼀的两点服务，即⼀条连接只有两个端点。</p>
<p>​	UDP ⽀持⼀对⼀、⼀对多、多对多的交互通信</p>
<p><em>3.</em> 可靠性</p>
<p>​	TCP 是可靠交付数据的，数据可以⽆差错、不丢失、不重复、按需到达。</p>
<p>​	UDP 是尽最⼤努⼒交付，不保证可靠交付数据。</p>
<p><em>4.</em> 拥塞控制、流量控制</p>
<p>​	TCP 有拥塞控制和流量控制机制，保证数据传输的安全性。</p>
<p>​	UDP 则没有，即使⽹络⾮常拥堵了，也不会影响 UDP 的发送速率。</p>
<p><em>5.</em> ⾸部开销</p>
<p>​	TCP ⾸部⻓度较⻓，会有⼀定的开销，⾸部在没有使⽤「选项」字段时是 20 个字节，如果使⽤了「选项」字段则会变⻓的。</p>
<p>​	UDP ⾸部只有 8 个字节，并且是固定不变的，开销较⼩。</p>
<p><em>6.</em> 传输⽅式</p>
<p>​	TCP 是流式传输，没有边界，但保证顺序和可靠。</p>
<p>​	UDP 是⼀个包⼀个包的发送，是有边界的，但可能会丢包和乱序。</p>
<p><em>7.</em> 分⽚不同</p>
<p>​	TCP 的数据⼤⼩如果⼤于 MSS ⼤⼩，则会在传输层进⾏分⽚，⽬标主机收到后，也同样在传输层组装 TCP数据包，如果中途丢失了⼀个分⽚，只需要传输丢失的这个分⽚。</p>
<p>​	UDP 的数据⼤⼩如果⼤于 MTU ⼤⼩，则会在 IP 层进⾏分⽚，⽬标主机收到后，在 IP 层组装完数据，接着再传给传输层，但是如果中途丢了⼀个分⽚，在实现可靠传输的 UDP 时则</p>
<p>​	就需要重传所有的数据包，这样传输效率⾮常差，所以通常 UDP 的报⽂应该⼩于 MTU。</p>
<h3 id="TCP-和-UDP-应⽤场景："><a href="#TCP-和-UDP-应⽤场景：" class="headerlink" title="TCP 和 UDP 应⽤场景："></a>TCP 和 UDP 应⽤场景：</h3><p>由于 TCP 是⾯向连接，能保证数据的可靠性交付，因此经常⽤于：</p>
<p>- FTP ⽂件传输</p>
<p>- HTTP &#x2F; HTTPS</p>
<p>由于 UDP ⾯向⽆连接，它可以随时发送数据，再加上UDP本身的处理既简单⼜⾼效，因此经常⽤于：</p>
<p>- 包总量较少的通信，如 DNS 、 SNMP 等</p>
<p>- 视频、⾳频等多媒体通信</p>
<p>- ⼴播通信</p>
<h3 id="为什么-UDP-头部没有「⾸部⻓度」字段，⽽-TCP-头部有「⾸部⻓度」字段呢"><a href="#为什么-UDP-头部没有「⾸部⻓度」字段，⽽-TCP-头部有「⾸部⻓度」字段呢" class="headerlink" title="为什么 UDP 头部没有「⾸部⻓度」字段，⽽ TCP 头部有「⾸部⻓度」字段呢?"></a>为什么 UDP 头部没有「⾸部⻓度」字段，⽽ TCP 头部有「⾸部⻓度」字段呢?</h3><p> TCP 有可变⻓的「选项」字段，⽽ UDP 头部⻓度则是不会变化的，⽆需多⼀个字段去记录</p>
<p> UDP 的⾸部⻓度。</p>
<h3 id="为什么-UDP-头部有「包⻓度」字段，⽽-TCP-头部则没有「包⻓度」字段呢？"><a href="#为什么-UDP-头部有「包⻓度」字段，⽽-TCP-头部则没有「包⻓度」字段呢？" class="headerlink" title="为什么 UDP 头部有「包⻓度」字段，⽽ TCP 头部则没有「包⻓度」字段呢？"></a>为什么 UDP 头部有「包⻓度」字段，⽽ TCP 头部则没有「包⻓度」字段呢？</h3><img src="/2024/04/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/clip_image012.gif" class="">

<p>其中 IP 总⻓度 和 IP ⾸部⻓度，在 IP ⾸部格式是已知的。TCP ⾸部⻓度，则是在 TCP ⾸部格式已知的，所以就可以求得 TCP 数据的⻓度。</p>
<p> UDP 也是基于 IP 层的呀，那 UDP 的数据⻓度也可以通过这个公式计算呀，为何还要有</p>
<p>「包⻓度」呢？”这么⼀问，确实感觉 UDP 「包⻓度」是冗余的。</p>
<p>因为为了⽹络设备硬件设计和处理⽅便，⾸部⻓度需要是 44 字节的整数倍。</p>
<p>如果去掉 UDP 「包⻓度」字段，那 UDP ⾸部⻓度就不是 4 字节的整数倍了，所以⼩林觉得这可能是为了补全</p>
<p>UDP ⾸部⻓度是 4 字节的整数倍，才补充了「包⻓度」字段。</p>
<h2 id="TCP-连接建⽴"><a href="#TCP-连接建⽴" class="headerlink" title="TCP 连接建⽴"></a>TCP 连接建⽴</h2><h3 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h3><img src="/2024/04/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/clip_image014.gif" class="">

<ul>
<li><p>- ⼀开始，客户端和服务端都处于 CLOSED 状态。先是服务端主动监听某个端⼝，处于 LISTEN 状态</p>
</li>
<li><p>- 客户端会随机初始化序号（ client_isn ），将此序号置于 TCP ⾸部的「序号」字段中，同时把 SYN 标志位置为 1 ，表示 SYN 报⽂。接着把第⼀个 SYN 报⽂发送给服务端，表示向服务端发起连接，该报⽂不包含应⽤层数据，之后客户端处于 SYN-SENT 状态。</p>
</li>
<li><p>- 服务端收到客户端的 SYN 报⽂后，⾸先服务端也随机初始化⾃⼰的序号（ server_isn ），将此序号填⼊TCP ⾸部的「序号」字段中，其次把 TCP ⾸部的「确认应答号」字段填⼊ client_isn + 1 , 接着把 SYN 和ACK 标志位置为 1 。最后把该报⽂发给客户端，该报⽂也不包含应⽤层数据，之后服务端处于 SYN-RCVD状态。</p>
</li>
<li><p>- 客户端收到服务端报⽂后，还要向服务端回应最后⼀个应答报⽂，⾸先该应答报⽂ TCP ⾸部 ACK 标志位置为1 ，其次「确认应答号」字段填⼊ server_isn + 1 ，最后把报⽂发送给服务端，这次报⽂可以携带客户到服务器的数据，之后客户端处于 ESTABLISHED 状态。</p>
</li>
<li><p>- 服务器收到客户端的应答报⽂后，也进⼊ ESTABLISHED 状态。</p>
</li>
</ul>
<p>第三次握⼿是可以携带数据的，前两次握⼿是不可以携带数据的，这也是⾯试常问的题</p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/53374516">https://zhuanlan.zhihu.com/p/53374516</a></p>
<h3 id="为什么是三次握⼿？不是两次、四次？"><a href="#为什么是三次握⼿？不是两次、四次？" class="headerlink" title="为什么是三次握⼿？不是两次、四次？"></a>为什么是三次握⼿？不是两次、四次？</h3><ul>
<li><p>- 三次握⼿才可以阻⽌重复历史连接的初始化（主要原因）</p>
</li>
<li><p>- 三次握⼿才可以同步双⽅的初始序列号</p>
</li>
<li><p>- 三次握⼿才可以避免资源浪费</p>
</li>
</ul>
<ol>
<li><p>阻⽌重复历史连接</p>
<p>客户端连续发送多次 SYN 建⽴连接的报⽂，在⽹络拥堵情况下：⼀个「旧 SYN 报⽂」⽐「最新的 SYN 」 报⽂早到达了服务端；那么此时服务端就会回⼀个 SYN + ACK 报⽂给客户端；客户端收到后可以根据⾃身的上下⽂，判断这是⼀个历史连接（序列号过期或超时），那么客户端就会发送RST 报⽂给服务端，表示中⽌这⼀次连接。</p>
<p>如果是两次握⼿连接，就不能判断当前连接是否是历史连接，三次握⼿则可以在客户端（发送⽅）准备发送第三次报⽂时，客户端因有⾜够的上下⽂来判断当前连接是否是历史连接：</p>
<p>如果是历史连接（序列号过期或超时），则第三次握⼿发送的报⽂是 RST 报⽂，以此中⽌历史连接；如果不是历史连接，则第三次发送的报⽂是 ACK 报⽂，通信双⽅就会成功建⽴连接；</p>
</li>
<li><p>同步双⽅的初始序列号</p>
<p>TCP 协议的通信双⽅， 都必须维护⼀个「序列号」， 序列号是可靠传输的⼀个关键因素，它的作⽤：</p>
<p>- 接收⽅可以去除重复的数据；</p>
<p>- 接收⽅可以根据数据包的序列号按序接收；</p>
<p>- 可以标识发送出去的数据包中， 哪些是已经被对⽅收到的；</p>
<p>四次握⼿其实也能够可靠的同步双⽅的初始化序号，但由于第⼆步和第三步可以优化成⼀步，所以就成了「三次握⼿」。⽽两次握⼿只保证了⼀⽅的初始序列号能被对⽅成功接收，没办法保证双⽅的初始序列号都能被确认接收。</p>
</li>
<li><p>三次握⼿才可以避免资源浪费</p>
<p>如果客户端的 SYN 阻塞了，重复发送多次 SYN 报⽂，那么服务器在收到请求后就会建⽴多个冗余的⽆效链接，造成不必要的资源浪费。</p>
</li>
</ol>
<h3 id="3次握手序列号的作用"><a href="#3次握手序列号的作用" class="headerlink" title="3次握手序列号的作用"></a>3次握手序列号的作用</h3><img src="/2024/04/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/clip_image015.jpg" class="" width="0">

<h2 id="TCP-连接断开"><a href="#TCP-连接断开" class="headerlink" title="TCP 连接断开"></a><strong>TCP</strong> <strong>连接断开</strong></h2><h3 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h3><img src="/2024/04/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/clip_image017.gif" class="">

<p>- 客户端打算关闭连接，此时会发送⼀个 TCP ⾸部 FIN 标志位被置为 1 的报⽂，也即 FIN 报⽂，之后客户端进⼊ FIN_WAIT_1 状态。</p>
<p>- 服务端收到该报⽂后，就向客户端发送 ACK 应答报⽂，接着服务端进⼊ CLOSED_WAIT 状态。</p>
<p>- 客户端收到服务端的 ACK 应答报⽂后，之后进⼊ FIN_WAIT_2 状态。</p>
<p>- 等待服务端处理完数据后，也向客户端发送 FIN 报⽂，之后服务端进⼊ LAST_ACK 状态。</p>
<p>- 客户端收到服务端的 FIN 报⽂后，回⼀个 ACK 应答报⽂，之后进⼊ TIME_WAIT 状态</p>
<p>- 服务器收到了 ACK 应答报⽂后，就进⼊了 CLOSED 状态，⾄此服务端已经完成连接的关闭。</p>
<p>- 客户端在经过 2MSL ⼀段时间后，⾃动进⼊ CLOSED 状态，⾄此客户端也完成连接的关闭。</p>
<p>主动关闭连接的，才有 <strong>TIME_WAIT</strong> 状态。</p>
<h3 id="为什么挥⼿需要四次？"><a href="#为什么挥⼿需要四次？" class="headerlink" title="为什么挥⼿需要四次？"></a>为什么挥⼿需要四次？</h3><p>- 关闭连接时，客户端向服务端发送 FIN 时，仅仅表示客户端不再发送数据了但是还能接收数据。</p>
<p>- 服务器收到客户端的 FIN 报⽂时，先回⼀个 ACK 应答报⽂，⽽服务端可能还有数据需要处理和发送，等服务端不再发送数据时，才发送 FIN 报⽂给客户端来表示同意现在关闭连接。</p>
<p>服务端通常需要等待完成数据的发送和处理，所以服务端的 ACK 和 FIN ⼀般都会分开发送，从⽽⽐三次握⼿导致多了⼀次。</p>
<h3 id="为什么-TIME-WAIT-等待的时间是-2MSL？"><a href="#为什么-TIME-WAIT-等待的时间是-2MSL？" class="headerlink" title="为什么 TIME_WAIT 等待的时间是 2MSL？"></a><strong>为什么</strong> <strong>TIME_WAIT</strong> <strong>等待的时间是</strong> <strong>2MSL？</strong></h3><p>MSL 是 Maximum Segment Lifetime，报⽂最⼤⽣存时间，它是任何报⽂在⽹络上存在的最⻓时间，超过这个时间报⽂将被丢弃。</p>
<p>TIME_WAIT 等待 2 倍的 MSL，⽐较合理的解释是： ⽹络中可能存在来⾃发送⽅的数据包，当这些发送⽅的数据包，被接收⽅处理后⼜会向对⽅发送响应，所以⼀来⼀回需要等待 <strong>2</strong> 倍的时间。</p>
<p>如果被动关闭⽅没有收到断开连接的最后的 ACK 报⽂，就会触发超时重发 Fin 报⽂，另⼀⽅接收到 FIN 后，会重发 ACK 给被动关闭⽅， ⼀来⼀去正好 2 个 MSL。</p>
<p>2MSL 的时间是从客户端接收到 <strong>FIN</strong> 后发送 <strong>ACK</strong> 开始计时的。如果在 TIME-WAIT 时间内，因为客户端的 ACK 没有传输到服务端，客户端⼜接收到了服务端重发的 FIN 报⽂，那么 <strong>2MSL</strong> 时间将重新计时。</p>
<h3 id="为什么需要-TIME-WAIT-状态？"><a href="#为什么需要-TIME-WAIT-状态？" class="headerlink" title="为什么需要 TIME_WAIT 状态？"></a><strong>为什么需要</strong> <strong>TIME_WAIT</strong> <strong>状态？</strong></h3><p>- 防⽌具有相同「四元组」的「旧」数据包被收到；</p>
<p>- 保证「被动关闭连接」的⼀⽅能被正确的关闭，即保证最后的 ACK 能让被动关闭⽅接收，从⽽帮助其正常关闭；</p>
<ol>
<li><p>防止旧数据包引起错乱：</p>
<p> 假设 TIME_WAIT 没有等待时间或时间过短,服务端在关闭连接之前发送的 SEQ &#x3D; 301 报⽂，被⽹络延迟了。这时有相同端⼝的 TCP 连接被复⽤后，被延迟的 SEQ &#x3D; 301 抵达了客户端，那么客户端是有可能正常接收这个过期的报⽂，这就会产⽣数据错乱等严乱的问题。</p>
<p> TCP 就设计出了这么⼀个机制，经过 2MSL 这个时间，⾜以让两个⽅向上的数据包都被丢弃，使得原来连接的数据包在⽹络中都⾃然消失，再出现的数据包⼀定都是新建⽴连接所产⽣的。</p>
</li>
<li><p>保证连接正确关闭：</p>
<p> TIME-WAIT 作⽤是等待⾜够的时间以确保最后的 <strong>ACK</strong> 能让被动关闭⽅接收，从⽽帮助其正常关闭。</p>
<p> 客户端四次挥⼿的最后⼀个 ACK 报⽂如果在⽹络中被丢失了，此时如果客户端 TIME-</p>
<p> WAIT过短或没有，则就直接进⼊了 CLOSED 状态了，那么服务端则会⼀直处在 LASE_ACK 状态。当客户端发起建⽴连接的 SYN 请求报⽂后，服务端会发送 RST 报⽂给客户端，连接建⽴的过程就会被终⽌。</p>
</li>
</ol>
<h2 id="TCP-如何保证可靠性传输"><a href="#TCP-如何保证可靠性传输" class="headerlink" title="TCP 如何保证可靠性传输"></a><strong>TCP</strong> <strong>如何保证可靠性传输</strong></h2><img src="/2024/04/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/clip_image019.jpg" class="" title="iii">

<h2 id="发送窗口的作用"><a href="#发送窗口的作用" class="headerlink" title="发送窗口的作用"></a>发送窗口的作用</h2><p>可靠传输，流量控制</p>
<img src="/2024/04/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/clip_image020.jpg" class="">

<img src="/2024/04/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/clip_image021.jpg" class="">

<img src="/2024/04/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/clip_image022.jpg" class="">

<img src="/2024/04/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/clip_image023.jpg" class="">

<img src="/2024/04/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/clip_image024.jpg" class="">

<img src="/2024/04/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/clip_image025.jpg" class="">

<img src="/2024/04/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/clip_image026.jpg" class="">

<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/lisuyun/articles/5803583.html">https://www.cnblogs.com/lisuyun/articles/5803583.html</a></p>
<h2 id="TCP的流量控制"><a href="#TCP的流量控制" class="headerlink" title="TCP的流量控制"></a><strong>TCP的流量控制</strong></h2><p>所谓流量控制就是让发送方的发送速率不要太快，让接收方来得及接收。因为如果发送方把数据发送得过快，接收方可能会来不及接收，这就会造成数据的丢失。TCP的流量控制是通过大小可变的滑动窗口来实现的。接收端将自己可以接收的缓冲区大小放入TCP首部中的“窗口大小”字段，通过ACK报文来通知发送端，滑动窗口是接收端用来控制发送端发送数据的大小，从而达到流量控制。</p>
<img src="/2024/04/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/clip_image028.jpg" class="" title="iii">

<p>设A向B发送数据。在连接建立时，B告诉了A：“我的接收窗口是 rwnd &#x3D; 400 ”(这里的 rwnd 表示 receiver window) 。因此，发送方的发送窗口不能超过接收方给出的接收窗口的数值。假设每一个报文段为100字节长，而数据报文段序号的初始值设为1。</p>
<img src="/2024/04/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E6%9C%AA%E5%91%BD%E5%90%8D%E5%9B%BE%E7%89%874.png" class="">

<p>从图中可以看出，B进行了三次流量控制。第一次把窗口减少到 rwnd &#x3D; 300 ，第二次又减到了 rwnd &#x3D; 100 ，最后减到 rwnd &#x3D; 0 ，即不允许发送方再发送数据了。这种使发送方暂停发送的状态将持续到主机B重新发出一个新的窗口值为止。B向A发送的三个报文段都设置了 ACK &#x3D; 1 ，只有在 ACK&#x3D;1 时确认号字段才有意义。</p>
<h2 id="TCP的拥塞控制"><a href="#TCP的拥塞控制" class="headerlink" title="TCP的拥塞控制"></a><strong>TCP的拥塞控制</strong></h2><p><strong>TCP的拥塞控制：</strong></p>
<p>拥塞控制就是防止过多的数据注入网络中，使网络中的路由器或链路不致过载。发送方维持一个拥塞窗口cwnd 的状态变量。拥塞窗口的大小动态变化，取决于网络的拥塞程度，发送方让自己的发送窗口等于拥塞窗口。只要网络没有出现拥塞，拥塞窗口就再增大一些，以便把更多的分组发送出去。但只要网络出现拥塞，拥塞窗口就减小一些，以减少注入到网络中的分组数。 拥塞控制的方法主要有以下几种：慢启动、拥塞避免、快重传和快恢复。</p>
<img src="/2024/04/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/clip_image032.jpg" class="" title="ii">

<img src="/2024/04/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/clip_image034.jpg" class="" title="iii">

<img src="/2024/04/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/clip_image036.jpg" class="" title="iii">

<img src="/2024/04/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/clip_image038.jpg" class="" title="iii">

<img src="/2024/04/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/clip_image040.jpg" class="" title="发 送 万  发 送 M 》  发 送 M2  发 送 M)  发 送 M" alt="发 送 Ms  收 到 三 个 连 续 的 发 送 M6  对 M2 的 重 复 确 认 送 Ml  立 即 重 传 Ms  t  接 收 方  确 认 Ml  确 认 M:  重 复 确 认 M2  重 复 确 认 Ma  重 复 确 认 M2  立 即 重 传 M  t">

<img src="/2024/04/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/clip_image042.jpg" class="" title="接 收 方 收 到 了 Ml 和 M2 后 都 分 别 发 出 了 确 认 。 现 在 假 定 接 收 方 没 有 收 到 M3 但 接 看 收 到 了 M4 。 显 然 ， 接 收 方 不 能 确 认 M4 ， 因 为 M4 是  收 到 的 失 序 报 文 段 。 根 据 可 靠 传 输 原 理 ， 接 收 方 可 以 什 么 都 不 做 ， 也 可 以 在 适 当 时 机 发 送 一 次 对 M2 的 确 认 。 但 按 照 快 重 传 篡 法 的 规  定 ， 接 收 方 应 及 时 发 送 对 M2 的 重 复 确 认 ， 汶 样 做 可 以 让 发 送 方 及 早 知 道 报 文 段 M3 没 有 到 达 接 收 方 。 发 送 方 接 看 发 送 了 M5 和 M6 。  接 收 方 收 到 汶 两 个 报 文 后 ， 也 还 要 再 次 发 出 对 M2 的 重 复 确 认 。 汶 样 ， 发 送 方 共 收 到 了 接 收 方 的 雪 个 对 M2 的 确 认 ， 其 中 后 三 个 都 是  重 复 确 认 。">

<img src="/2024/04/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/clip_image044.jpg" class="" title="（ 4 ） 快 恢 复 ： 与 快 重 传 配 台 便 用 的 还 有 快 预 复 法 当 发 送 方 连 续 收 到 三 个 复 确 认 时 ， 就 执 行 。 词 去 减 少 篡 法 ， *Essthresh 门 限设舀 为 塞 窗 口 cwnd 的 一 半 ， 但 是 接 下 去 并 不 执 行 开 始 法 而 是 为 ssthreshB5 大 小 ， 然 后 执 行 裤 塞 避 免 法 ： 因 为 如 果 网 纟 各 出 现 塞 的 话 ， 就 不 会 收 到 好 几 个 复 的 确 认 ， 所 以 发 送 方 现 在 认 为 网 络 可 能 没 有 出 现 塞 ， 所 以 此 时 并 不 执 行 开 始 法 而 是 执 行 塞 避 免 法 。 %}

{% asset_img clip_image046.jpg&quot; iii">

<p><strong>4、拥塞控制和流量控制的差别：</strong></p>
<img src="/2024/04/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/clip_image048.jpg" class="" title="（ 1 ） 相 同 点 ． 塞 控 制 和 流 畢 控 制 的 相 同 点 都 是 控 制 丢 包 现 象 ， 实 现 机 制 都 是 让 发 送 方 发 得 一 点 。  （ 2 ） 不 同 点  @ 裤 塞 控 制 是 一 个 全 局 性 的 过 程 ， 防 到 寸 多 的 数 据 氵 三 到 络 中 ， 造 成 络 裤 塞  2 流 量 控 制 指 点 对 点 信 量 的 控 制 ， 要 做 的 就 是 控 制 发 送 端 发 送 数 据 的 涑 率 ， 以 便 便 接 收 揣 来 得 及 接 受 。">

<h2 id="拥塞控制和流量控制的差别"><a href="#拥塞控制和流量控制的差别" class="headerlink" title="拥塞控制和流量控制的差别"></a><strong>拥塞控制和流量控制的差别</strong></h2><p><strong>拥塞控制和流量控制的差别：</strong></p>
<img src="/2024/04/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/clip_image048.jpg" class="" title="（ 1 ） 相 同 点 ． 塞 控 制 和 流 畢 控 制 的 相 同 点 都 是 控 制 丢 包 现 象 ， 实 现 机 制 都 是 让 发 送 方 发 得 一 点 。  （ 2 ） 不 同 点  @ 裤 塞 控 制 是 一 个 全 局 性 的 过 程 ， 防 到 寸 多 的 数 据 氵 三 到 络 中 ， 造 成 络 裤 塞  2 流 量 控 制 指 点 对 点 信 量 的 控 制 ， 要 做 的 就 是 控 制 发 送 端 发 送 数 据 的 涑 率 ， 以 便 便 接 收 揣 来 得 及 接 受 。">

<h2 id="半连接和全连接队列"><a href="#半连接和全连接队列" class="headerlink" title="半连接和全连接队列"></a>半连接和全连接队列</h2><img src="/2024/04/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/clip_image050.jpg" class="" width="0">

<p>半连接队列 max_qlen_log 的最⼤值为 256：</p>
<h2 id="SYN洪泛"><a href="#SYN洪泛" class="headerlink" title="SYN洪泛"></a>SYN洪泛</h2><p>SYN 洪泛是指利用 TCP 需要三次握手的特性，攻击者伪造 SYN 报文向服务器发起连接，服务器在收到报文后用 ACK 应答，但之后攻击者不再对该响应进行应答，造成一个半连接。假设攻击者发送大量这样的报文，那么被攻击主机就会造成大量的半连接，耗尽其资源，导致正常的 SYN 请求因为队列满而被丢弃，使得正常用户无法访问。</p>
<p><strong>如何防御 SYN 攻击？</strong> </p>
<ul>
<li><p>增⼤半连接队列；</p>
</li>
<li><p>开启 tcp_syncookies 功能 </p>
</li>
<li><p>减少 SYN+ACK 重传次数</p>
</li>
</ul>
<img src="/2024/04/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/clip_image051.jpg" class="" width="0">

<img src="/2024/04/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/clip_image052.jpg" class="" width="0">

<h2 id="TCP的粘包和拆包"><a href="#TCP的粘包和拆包" class="headerlink" title="TCP的粘包和拆包"></a>TCP的粘包和拆包</h2><img src="/2024/04/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/clip_image054.jpg" class="" title="解 决 粘 包 和 拆 包 的 方 法 主 要 有  （ 1 ） 在 数 据 尾 部 增 加 特 殊 字 符 进 行 分 割 ；  （ 2 ） 将 数 庭 定 为 固 定 大 小 ；  （ 3 ） 将 数 庭 分 为 两 部 分 ， 一 部 分 是 头 部 ， 一 部 分 是 内 容 体 ； 其 中 头 部 结 构 大 小 固 定 ， 且 有 一 个 段 声 明 内 容 体 的 大 小">

<h1 id="cookie和session的区别"><a href="#cookie和session的区别" class="headerlink" title="cookie和session的区别"></a>cookie和session的区别</h1><ol>
<li>session 在服务器端，cookie 在客户端（浏览器）</li>
<li>cookie不是很安全</li>
<li>单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie。(Session对象没有对存储的数据量的限制，其中可以保存更为复杂的数据类型)</li>
<li>session 可以放在 文件、数据库、或内存中都可以。</li>
<li>session 的运行依赖 session id，而     session id 是存在 cookie 中的，也就是说，如果浏览器禁用了 cookie ，同时 session 也会失效（但是可以通过其它方式实现，比如在 url 中传递 session_id） </li>
<li>用户验证这种场合一般会用 session</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://note.youdao.com/web/#/file/WEBdf61c6d9c265f941ef73b769d6b154e1/note/WEB0b3584b248ac60abe3a432744701e3f1/">https://note.youdao.com/web/#/file/WEBdf61c6d9c265f941ef73b769d6b154e1/note/WEB0b3584b248ac60abe3a432744701e3f1/</a></p>
<h1 id="DNS域名解析过程"><a href="#DNS域名解析过程" class="headerlink" title="DNS域名解析过程"></a>DNS域名解析过程</h1><p>缓存 本地的hosts文件 本地DNS解析器缓存 本地DNS服务器 根据设置的转发器</p>
<p><strong>DNS解析过程：</strong></p>
<p>场景：用户在浏览器输入网址：clondant.blog.51cto.com，其解析过程如下：</p>
<p><strong>第1步：</strong>浏览器将会检查缓存中有没有这个域名对应的解析过的IP地址，如果有该解析过程将会结束。</p>
<p><strong>第2步：</strong>如果用户的浏览器中缓存中没有，操作系统会先检查自己本地的hosts文件是否有这个网址映射关系，如果有，就先调用这个IP地址映射关系，完成域名解析。</p>
<p><strong>第3步：</strong>如果hosts里没有这个域名的映射，则查找本地DNS解析器缓存，是否有这个网址映射关系或缓存信息，如果有，直接返回给浏览器，完成域名解析。</p>
<p><strong>第4步：</strong>如果hosts与本地DNS解析器缓存都没有相应的网址映射关系，则会首先找本地DNS服务器，一般是公司内部的DNS服务器，此服务器收到查询，如果此本地DNS服务器查询到相对应的IP地址映射或者缓存信息，则返回解析结果给客户机，完成域名解析，此解析具有权威性。</p>
<p><strong>第5步：</strong>如果本地DNS服务器无法查询到，则根据本地DNS服务器设置的转发器进行查询；</p>
<p><strong>未用转发模式：</strong>本地DNS就把请求发至根DNS进行<strong>（迭代）查询</strong>，根DNS服务器收到请求后会判断这个域名(.com)是谁来授权管理，并会返回一个负责该顶级域名服务器的一个IP。本地DNS服务器收 到IP信息后，将会联系负责.com域的这台服务器。这台负责.com域的服务器收到请求后，如果自己无法解析，它就会找一个管理.com域的下一级 DNS服务器地址给本地DNS服务器。当本地DNS服务器收到这个地址后，就会找域名域服务器，重复上面的动作，进行查询，直至找到域名对应的主机。</p>
<p><strong>使用转发模式：</strong>此DNS服务器就会把请求转发至上一级DNS服务器，由上一级服务器进行解析，上一级服务器如果不能解析，或找根DNS或把转请求转至 上上级，以此循环。不管是本地DNS服务器用是是转发，还是根提示，最后都是把结果返回给本地DNS服务器，由此DNS服务器再返回给客户机。</p>
<p>搭建基本的DNS服务</p>
<p><a target="_blank" rel="noopener" href="https://www.huaweicloud.com/articles/a05aa2b2e729535533c20925cabb07b4.html">https://www.huaweicloud.com/articles/a05aa2b2e729535533c20925cabb07b4.html</a></p>
<h1 id="ARQ协议"><a href="#ARQ协议" class="headerlink" title="ARQ协议"></a><strong>ARQ协议</strong></h1><p><strong>ARQ协议:</strong></p>
<img src="/2024/04/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/clip_image056.jpg" class="" title="自 动 重 传 请 求 MutomaticRepeat-reQuest ARQ) 是 O 引 模 型 中 数 据 链 路 层 和 传 输 层 的 错 误 纠  正 协 议 之 一 。 它 通 过 使 用 确 认 和 超 时 这 两 个 机 制 ， 在 不 可 靠 服 务 的 基 础 上 实 现 可 靠 的 信 息 传 输 。  如 果 发 送 方 在 发 送 后 一 段 时 间 之 内 没 有 收 到 确 认 帧 ， 它 通 常 会 重 新 发 送 。 ARQ 包 括 停 止 等 待 ARQ  协 议 和 连 续 ARQ 协 议 。">

<h1 id="一些专业词汇"><a href="#一些专业词汇" class="headerlink" title="一些专业词汇"></a>一些专业词汇</h1><ol>
<li><p>MSS</p>
<p>最大报文段长度是TCP协议的一个选项，用于在TCP连接建立时，收发双方协商通信时每一个报文段所能承载的最大数据长度</p>
</li>
<li><p>MTU</p>
<p><em>mtu</em>一般指最大传输单元。最大传输单元（Maximum Transmission Unit，<em>MTU</em>）用来通知对方所能接受数据服务单元的最大尺寸，说明发送方能够接受的有效载荷大小</p>
</li>
<li><p>MSL 是 Maximum Segment Lifetime，报⽂最⼤⽣存时间，</p>
</li>
<li><p>SYN：同步序列编号（Synchronize Sequence Numbers）。是TCP&#x2F;IP建立连接时使用的握手信号。</p>
</li>
<li><p>ACK (Acknowledge character）即是确认字符，在数据通信中，接收站发给发送站的一种传输类<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E6%8E%A7%E5%88%B6%E5%AD%97%E7%AC%A6/6913704">控制字符</a>。表示发来的数据已确认接收无误</p>
</li>
<li><p>FIFO先进先出队列</p>
</li>
<li><p>线程挂起的方法,就是park,对应唤醒就是unpark。</p>
</li>
<li><p>OSPF(Open Shortest Path First开放式最短路径优先）是一个内部网关协议(Interior Gateway Protocol）</p>
</li>
<li><p>SSL 的英文全称是 “Secure Sockets Layer” ，中文名为 “ 安全套接层协议层 </p>
</li>
<li><p>安全传输层协议（TLS）用于在两个通信应用程序之间提供保密性和数据完整性。</p>
</li>
</ol>
<h1 id="非对称加密的应用"><a href="#非对称加密的应用" class="headerlink" title="非对称加密的应用"></a>非对称加密的应用</h1><ol>
<li><p>用于身份认证</p>
<p>一条加密信息若能用A 的公钥能解开，则该信息一定是用A 的私钥加密的，该能确定该用户是A。</p>
</li>
</ol>
<img src="/2024/04/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/clip_image058.gif" class="">

<ol start="2">
<li><p>用于陌生人通信</p>
<p>A 和B 两个人互不认识，A 把自己的公钥发给B，B 也把自己的公钥发给A，则双方可以通过对方的公钥加密信息通信。C 虽然也能得到A、B 的公钥，但是他解不开密文。</p>
</li>
</ol>
<img src="/2024/04/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/clip_image060.gif" class="">

<ol start="3">
<li><p>用于敏感的秘钥交换场景下</p>
<p>A 先得到B 的公钥，然后A 生成一个随机秘钥，例如13245768，之后A 用B 的公钥加密该秘钥，得到加密后的秘钥，例如dxs#fd@dk，之后将该密文发给B，B 用自己的私钥解密得到123456，之后双方使用13245768 作为对称加密的秘钥通信。C 就算截获加密后的秘钥dxs#fd@dk，自己也解不开，这样A、B 二人能通过对称加密进行通信。</p>
</li>
</ol>
<img src="/2024/04/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/clip_image062.gif" class="">

<p><strong>本文小结</strong></p>
<p>非对称加密一般不会单独拿来使用，他并不是为了取代对称加密而出现的，非对称加密速度比对称加密慢很多，极端情况下会慢1000 倍，所以一般不会用来加密大量数据，通常我们经常会将对称加密和非对称加密两种技术联合起来使用，例如用非对称加密来给称加密里的秘钥进行加密（即秘钥交换）。</p>
<h1 id="跨域"><a href="#跨域" class="headerlink" title="跨域"></a>跨域</h1><img src="/2024/04/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/clip_image064.jpg" class="">


                
            </div>
            <hr/>

            

    <div class="reprint" id="reprint-statement">
        
            <div class="reprint__author">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-user">
                        文章作者:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="/about" rel="external nofollow noreferrer">小智同学</a>
                </span>
            </div>
            <div class="reprint__type">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-link">
                        文章链接:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="http://example.com/2024/04/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">http://example.com/2024/04/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</a>
                </span>
            </div>
            <div class="reprint__notice">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-copyright">
                        版权声明:
                    </i>
                </span>
                <span class="reprint-info">
                    本博客所有文章除特別声明外，均采用
                    <a href="https://creativecommons.org/licenses/by/4.0/deed.zh" rel="external nofollow noreferrer" target="_blank">CC BY 4.0</a>
                    许可协议。转载请注明来源
                    <a href="/about" target="_blank">小智同学</a>
                    !
                </span>
            </div>
        
    </div>

    <script async defer>
      document.addEventListener("copy", function (e) {
        let toastHTML = '<span>复制成功，请遵循本文的转载规则</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">查看</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }
    </script>



            <div class="tag_share" style="display: block;">
                <div class="post-meta__tag-list" style="display: inline-block;">
                    
                        <div class="article-tag">
                            
                                <a href="/tags/java%E9%9D%A2%E8%AF%95/">
                                    <span class="chip bg-color">java面试</span>
                                </a>
                            
                                <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">
                                    <span class="chip bg-color">计算机网络</span>
                                </a>
                            
                        </div>
                    
                </div>
                <div class="post_share" style="zoom: 80%; width: fit-content; display: inline-block; float: right; margin: -0.15rem 0;">
                    <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">
<div id="article-share">

    
    <div class="social-share" data-sites="twitter,facebook,google,qq,qzone,wechat,weibo,douban,linkedin" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div>
    <script src="/libs/share/js/social-share.min.js"></script>
    

    

</div>

                </div>
            </div>
            
                <div id="reward">
    <a href="#rewardModal" class="reward-link modal-trigger btn-floating btn-medium waves-effect waves-light red">赏</a>

    <!-- Modal Structure -->
    <div id="rewardModal" class="modal">
        <div class="modal-content">
            <a class="close modal-close"><i class="fas fa-times"></i></a>
            <h4 class="reward-title">你的赏识是我前进的动力</h4>
            <div class="reward-content">
                <div class="reward-tabs">
                    <ul class="tabs row">
                        <li class="tab col s6 alipay-tab waves-effect waves-light"><a href="#alipay">支付宝</a></li>
                        <li class="tab col s6 wechat-tab waves-effect waves-light"><a href="#wechat">微 信</a></li>
                    </ul>
                    <div id="alipay">
                        <img src="/medias/reward/alipay.jpg" class="reward-img" alt="支付宝打赏二维码">
                    </div>
                    <div id="wechat">
                        <img src="/medias/reward/wechat.png" class="reward-img" alt="微信打赏二维码">
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
    $(function () {
        $('.tabs').tabs();
    });
</script>

            
        </div>
    </div>

    

    

    

    

    

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fas fa-chevron-left"></i>&nbsp;上一篇</div>
            <div class="card">
                <a href="/2024/04/07/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/3.jpg" class="responsive-img" alt="操作系统">
                        
                        <span class="card-title">操作系统</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                        <span class="publish-date">
                            <i class="far fa-clock fa-fw icon-date"></i>2024-04-07
                        </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/java%E9%9D%A2%E7%BB%8F/" class="post-category">
                                    java面经
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/java%E9%9D%A2%E8%AF%95/">
                        <span class="chip bg-color">java面试</span>
                    </a>
                    
                    <a href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">
                        <span class="chip bg-color">操作系统</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fas fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/2024/04/06/Mybatis/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/5.jpg" class="responsive-img" alt="Mybatis">
                        
                        <span class="card-title">Mybatis</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2024-04-06
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/java%E9%9D%A2%E7%BB%8F/" class="post-category">
                                    java面经
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/java%E9%9D%A2%E8%AF%95/">
                        <span class="chip bg-color">java面试</span>
                    </a>
                    
                    <a href="/tags/Mybatis/">
                        <span class="chip bg-color">Mybatis</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>

</div>



<!-- 代码块功能依赖 -->
<script type="text/javascript" src="/libs/codeBlock/codeBlockFuction.js"></script>



<!-- 代码语言 -->

<script type="text/javascript" src="/libs/codeBlock/codeLang.js"></script>


<!-- 代码块复制 -->

<script type="text/javascript" src="/libs/codeBlock/codeCopy.js"></script>


<!-- 代码块收缩 -->

<script type="text/javascript" src="/libs/codeBlock/codeShrink.js"></script>



    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget card" style="background-color: white;">
            <div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fas fa-list-ul"></i>
    </a>
</div>


<script src="/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            collapseDepth: Number('0'),
            headingSelector: 'h1, h2, h3, h4'
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).hide();
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).show();
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>

    

</main>




    <footer class="page-footer bg-color">
    
        <link rel="stylesheet" href="/libs/aplayer/APlayer.min.css">
<style>
    .aplayer .aplayer-lrc p {
        
        display: none;
        
        font-size: 12px;
        font-weight: 700;
        line-height: 16px !important;
    }

    .aplayer .aplayer-lrc p.aplayer-lrc-current {
        
        display: none;
        
        font-size: 15px;
        color: #42b983;
    }

    
    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body {
        left: -66px !important;
    }

    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body:hover {
        left: 0px !important;
    }

    
</style>
<div class="">
    
    <div class="row">
        <meting-js class="col l8 offset-l2 m10 offset-m1 s12"
                   server="netease"
                   type="playlist"
                   id="503838841"
                   fixed='true'
                   autoplay='false'
                   theme='#42b983'
                   loop='all'
                   order='random'
                   preload='auto'
                   volume='0.7'
                   list-folded='true'
        >
        </meting-js>
    </div>
</div>

<script src="/libs/aplayer/APlayer.min.js"></script>
<script src="/libs/aplayer/Meting.min.js"></script>

    

    <div class="container row center-align"
         style="margin-bottom: 15px !important;">
        <div class="col s12 m8 l8 copy-right">
            Copyright&nbsp;&copy;
            
                <span id="year">2024</span>
            
            <a href="/about" target="_blank">小智同学</a>
            
            
            <br>
            
                &nbsp;<i class="fas fa-chart-area"></i>&nbsp;站点总字数:&nbsp;<span
                        class="white-color">155.8k</span>
            
            
            
                
            
            
                <span id="busuanzi_container_site_pv">
                &nbsp;|&nbsp;<i class="far fa-eye"></i>&nbsp;总访问量:&nbsp;
                    <span id="busuanzi_value_site_pv" class="white-color"></span>
            </span>
            
            
                <span id="busuanzi_container_site_uv">
                &nbsp;|&nbsp;<i class="fas fa-users"></i>&nbsp;总访问人数:&nbsp;
                    <span id="busuanzi_value_site_uv" class="white-color"></span>
            </span>
            
            <br>

            <!-- 运行天数提醒. -->
            
                <span id="sitetime"> Loading ...</span>
                <script>
                    var calcSiteTime = function () {
                        var seconds = 1000;
                        var minutes = seconds * 60;
                        var hours = minutes * 60;
                        var days = hours * 24;
                        var years = days * 365;
                        var today = new Date();
                        var startYear = "2024";
                        var startMonth = "3";
                        var startDate = "26";
                        var startHour = "0";
                        var startMinute = "0";
                        var startSecond = "0";
                        var todayYear = today.getFullYear();
                        var todayMonth = today.getMonth() + 1;
                        var todayDate = today.getDate();
                        var todayHour = today.getHours();
                        var todayMinute = today.getMinutes();
                        var todaySecond = today.getSeconds();
                        var t1 = Date.UTC(startYear, startMonth, startDate, startHour, startMinute, startSecond);
                        var t2 = Date.UTC(todayYear, todayMonth, todayDate, todayHour, todayMinute, todaySecond);
                        var diff = t2 - t1;
                        var diffYears = Math.floor(diff / years);
                        var diffDays = Math.floor((diff / days) - diffYears * 365);

                        // 区分是否有年份.
                        var language = 'zh-CN';
                        if (startYear === String(todayYear)) {
                            document.getElementById("year").innerHTML = todayYear;
                            var daysTip = 'This site has been running for ' + diffDays + ' days';
                            if (language === 'zh-CN') {
                                daysTip = '本站已运行 ' + diffDays + ' 天';
                            } else if (language === 'zh-HK') {
                                daysTip = '本站已運行 ' + diffDays + ' 天';
                            }
                            document.getElementById("sitetime").innerHTML = daysTip;
                        } else {
                            document.getElementById("year").innerHTML = startYear + " - " + todayYear;
                            var yearsAndDaysTip = 'This site has been running for ' + diffYears + ' years and '
                                + diffDays + ' days';
                            if (language === 'zh-CN') {
                                yearsAndDaysTip = '本站已运行 ' + diffYears + ' 年 ' + diffDays + ' 天';
                            } else if (language === 'zh-HK') {
                                yearsAndDaysTip = '本站已運行 ' + diffYears + ' 年 ' + diffDays + ' 天';
                            }
                            document.getElementById("sitetime").innerHTML = yearsAndDaysTip;
                        }
                    }

                    calcSiteTime();
                </script>
            
            <br>
            
        </div>
        <div class="col s12 m4 l4 social-link social-statis">
    <a href="https://github.com/yongbozhi" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">
        <i class="fab fa-github"></i>
    </a>















    <a href="/atom.xml" class="tooltipped" target="_blank" data-tooltip="RSS 订阅" data-position="top" data-delay="50">
        <i class="fas fa-rss"></i>
    </a>

</div>
    </div>
</footer>

<div class="progress-bar"></div>


    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script type="text/javascript">
$(function () {
    var searchFunc = function (path, search_id, content_id) {
        'use strict';
        $.ajax({
            url: path,
            dataType: "xml",
            success: function (xmlResponse) {
                // get the contents from search data
                var datas = $("entry", xmlResponse).map(function () {
                    return {
                        title: $("title", this).text(),
                        content: $("content", this).text(),
                        url: $("url", this).text()
                    };
                }).get();
                var $input = document.getElementById(search_id);
                var $resultContent = document.getElementById(content_id);
                $input.addEventListener('input', function () {
                    var str = '<ul class=\"search-result-list\">';
                    var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
                    $resultContent.innerHTML = "";
                    if (this.value.trim().length <= 0) {
                        return;
                    }
                    // perform local searching
                    datas.forEach(function (data) {
                        var isMatch = true;
                        var data_title = data.title.trim().toLowerCase();
                        var data_content = data.content.trim().replace(/<[^>]+>/g, "").toLowerCase();
                        var data_url = data.url;
                        data_url = data_url.indexOf('/') === 0 ? data.url : '/' + data_url;
                        var index_title = -1;
                        var index_content = -1;
                        var first_occur = -1;
                        // only match artiles with not empty titles and contents
                        if (data_title !== '' && data_content !== '') {
                            keywords.forEach(function (keyword, i) {
                                index_title = data_title.indexOf(keyword);
                                index_content = data_content.indexOf(keyword);
                                if (index_title < 0 && index_content < 0) {
                                    isMatch = false;
                                } else {
                                    if (index_content < 0) {
                                        index_content = 0;
                                    }
                                    if (i === 0) {
                                        first_occur = index_content;
                                    }
                                }
                            });
                        }
                        // show search results
                        if (isMatch) {
                            str += "<li><a href='" + data_url + "' class='search-result-title'>" + data_title + "</a>";
                            var content = data.content.trim().replace(/<[^>]+>/g, "");
                            if (first_occur >= 0) {
                                // cut out 100 characters
                                var start = first_occur - 20;
                                var end = first_occur + 80;
                                if (start < 0) {
                                    start = 0;
                                }
                                if (start === 0) {
                                    end = 100;
                                }
                                if (end > content.length) {
                                    end = content.length;
                                }
                                var match_content = content.substr(start, end);
                                // highlight all keywords
                                keywords.forEach(function (keyword) {
                                    var regS = new RegExp(keyword, "gi");
                                    match_content = match_content.replace(regS, "<em class=\"search-keyword\">" + keyword + "</em>");
                                });

                                str += "<p class=\"search-result\">" + match_content + "...</p>"
                            }
                            str += "</li>";
                        }
                    });
                    str += "</ul>";
                    $resultContent.innerHTML = str;
                });
            }
        });
    };

    searchFunc('/search.xml', 'searchInput', 'searchResult');
});
</script>

    <!-- 白天和黑夜主题 -->
<div class="stars-con">
    <div id="stars"></div>
    <div id="stars2"></div>
    <div id="stars3"></div>  
</div>

<script>
    function switchNightMode() {
        $('<div class="Cuteen_DarkSky"><div class="Cuteen_DarkPlanet"></div></div>').appendTo($('body')),
        setTimeout(function () {
            $('body').hasClass('DarkMode') 
            ? ($('body').removeClass('DarkMode'), localStorage.setItem('isDark', '0'), $('#sum-moon-icon').removeClass("fa-sun").addClass('fa-moon')) 
            : ($('body').addClass('DarkMode'), localStorage.setItem('isDark', '1'), $('#sum-moon-icon').addClass("fa-sun").removeClass('fa-moon')),
            
            setTimeout(function () {
            $('.Cuteen_DarkSky').fadeOut(1e3, function () {
                $(this).remove()
            })
            }, 2e3)
        })
    }
</script>

    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fas fa-arrow-up"></i>
    </a>
</div>


    <script src="/libs/materialize/materialize.min.js"></script>
    <script src="/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="/libs/aos/aos.js"></script>
    <script src="/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="/js/matery.js"></script>

    

    
    
    
        
        <script type="text/javascript">
            // 只在桌面版网页启用特效
            var windowWidth = $(window).width();
            if (windowWidth > 768) {
                document.write('<script type="text/javascript" src="/libs/others/sakura.js"><\/script>');
            }
        </script>
    

    <!-- 雪花特效 -->
    

    <!-- 鼠标星星特效 -->
    

     
        <script src="https://ssl.captcha.qq.com/TCaptcha.js"></script>
        <script src="/libs/others/TencentCaptcha.js"></script>
        <button id="TencentCaptcha" data-appid="xxxxxxxxxx" data-cbfn="callback" type="button" hidden></button>
    

    <!-- Baidu Analytics -->

    <!-- Baidu Push -->

<script>
    (function () {
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        } else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>

    
    <script src="/libs/others/clicklove.js" async="async"></script>
    
    
    <script async src="/libs/others/busuanzi.pure.mini.js"></script>
    

    

    

    <!--腾讯兔小巢-->
    
    

    

    

    
    <script src="/libs/instantpage/instantpage.js" type="module"></script>
    

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"log":false,"model":{"jsonPath":"/live2dw/assets/shizuku.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true},"react":{"opacity":0.7}});</script></body>

</html>
